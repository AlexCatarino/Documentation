<p>The simplest form of history request is for a known set of Symbols. This is common for fixed universes of securities, or when you'd like to warm up new securities added to your algorithm.
</p>

<p class="python">
History requests for a known set of Symbols return a Data Frame. Each row of the Data Frame represents the prices at a point of time. Each <i>column</i> of the Data Frame is a property of that price data (e.g. open, high, low, close). 
</p>

<p class="csharp">
History requests return slightly different data depending on if you ask with 1-Symbol or an array of Symbols. With 1-Symbol you get an array of the security data. With multiple security history requests, we cannot guarantee all the data types are the same format, so we return an array of Slices instead. E.g. A history request for FX-QuoteBars + Equity-TradeBars is returned as an array of Slices; where the FX data is located under <code>slices.QuoteBars</code>, and the Equity data is under <code>slices.Bars</code>.
</p>

<p>
History API calls follow the following pattern: <code class="python">self.History(symbol, bar_count, resolution = null)</code> <code class="csharp">History&lt;Type&gt;(Symbol symbol, int barCount, Resolution resolution = null)</code>.
</p>


<div class="section-example-container">
<pre class="python"># Requesting By Bar Count: 7 IBM TradeBars 
self.df = self.History(self.Symbol("IBM"), 7)
self.df = self.History(self.Symbol("IBM"), 7, Resolution.Minute)


# Requestion By Period: 1 Week Of IBM Data.
self.df = self.History(self.Symbol("IBM"), timedelta(7)) 
self.df = self.History(self.Symbol("IBM"), timedelta(7), Resolution.Minute)
</pre>
<pre class="csharp fsharp">// Requesting By Bar Count: 7 IBM TradeBars
var bars = History&lt;TradeBar&gt;("IBM", 7);
var bars = History&lt;TradeBar&gt;("IBM", 7, Resolution.Minute);

// Requestion By Period: 1 Week Of IBM Data
var bars = History&lt;TradeBar&gt;("IBM", TimeSpan.FromDays(7));
var bars = History&lt;TradeBar&gt;("IBM", TimeSpan.FromDays(7), Resolution.Minute);
</pre>
</div>

<p class="python">
<img class="img-responsive img-thumbnail " src="http://cdn.quantconnect.com/docs/i/history-simple-bars_rev1.png">
<b>Example 1: Querying via research has the same API as your backtests.</b>
</p>

<h4>Assumed Default Values</h4>
<ol>
<li> Resolution. An important distinction exists between the two examples above, one is using the default value for Resolution. Here LEAN attempts to guess the resolution you request by looking at any securities you already have in your algorithm. If you have a matching Symbol, QuantConnect will use the same resolution. When no default values can be located <code>Resolution.Minute</code> is selected.
</li>
<li class="csharp">
When no type is specified for the history request <code>TradeBar</code> is assumed for Equity, Futures Crypto and Options securities. Assets with QuoteBar data must explicitly specify Quotes to receive their history (Forex, Futures, Options, and Crypto).
</li>
</ol>

 
