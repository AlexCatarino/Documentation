<meta name="tag" content="universes" />
<meta name="tag" content="coarse universes" />

<p>
Coarse Universe selection allows you to pick a set of stocks by its volume, price or whether it has fundamental data. This is helpful to narrow down your universe to liquid assets, or assets which pass a technical indicator filter.
</p>

<p>
To use a coarse universe you must request it using an $[AddUniverse(), M:QuantConnect.Algorithm.QCAlgorithm.AddUniverse] call from the Initialize() method of your algorithm. You should pass in a function which will be used to filter the stocks down to the assets you are interested in using.
</p>
<div class="section-example-container" >
<pre class="csharp">
public class MyCoarseUniverseAlgorithm : QCAlgorithm {
    public override void Initialize() {
        AddUniverse(MyCoarseFilterFunction);
    }
    // Coarse Filter Function accepts a list of CoarseFundamental Objects. 
    IEnumerable&lt;Symbol&gt; MyCoarseFilterFunction(IEnumerable&lt;CoarseFundamental&gt; coarse) {
         
    }
}
</pre>
<pre class="python">
class MyCoarseUniverseAlgorithm(QCAlgorithm):
     def Initialize(self):
         self.AddUniverse(self.MyCoarseFilterFunction)

    def MyCoarseFilterFunction(self, coarse):
         pass
</pre>
</div>

<p>
The coarse filter function is provided a list of $[CoarseFundamental,T:QuantConnect.Data.UniverseSelection.CoarseFundamental] objects. The most important properties of this object are: <code>Price</code>, <code>DollarVolume</code> and <code>HasFundamentaData</code>. Typical examples of filter functions you might want sound like: 
</p>
<h4>Example 1: Take 500 stocks worth more than $10, with more than $10M daily trading volume.</h4>
<p>
The most common use case is selecting a lot of liquid stocks. With coarse this is simple and fast. This example below of a coarse filter function selects the top most liquid 500 stocks over $10 per share.
</p>
<div class="section-example-container" >
<pre class="csharp">
    IEnumerable&lt;Symbol&gt; MyCoarseFilterFunction(IEnumerable&lt;CoarseFundamental&gt; coarse) {
        // Linq makes this a piece of cake;
        var stocks = (from c in coarse
            where c.DollarVolume > 10000000 &&
                  c.Price > 10
            orderby c.DollarVolume descending
            select c.Symbol).Take(500).ToList();
        return stocks;
    }
</pre>
<pre class="python">
    def MyCoarseFilterFunction(self, coarse):
         sortedByDollarVolume = sorted(coarse, key=lambda x: x.DollarVolume, reverse=True)
         filtered = [ x.Symbol for x in sortedByDollarVolume 
                      if x.Price > 10 and x.DollarVolume > 10000000 ]
         return filtered[:500]
</pre>
</div>


<h4>Example 2: Take 10 stocks above their 200-Day EMA with more than $1B daily trading volume.</h4>
<p>
Another common request is to filter the universe by a technical indicator, such as only picking those above their 200-day EMA. The coarse fundamental object has adjusted price and volume information so we can do any price related analysis and return the symbols which pass our filter.
</p>
<div class="section-example-container" >
<pre class="csharp">
    ConcurrentDictionary&lt;Symbol, SelectionData&gt 
        _stateData = new ConcurrentDictionary&lt;Symbol, SelectionData&gt();

    // Coarse filter function
    IEnumerable&lt;Symbol&gt; MyCoarseFilterFunction(IEnumerable&lt;CoarseFundamental&gt; coarse) {
        // Linq makes this a piece of cake;
        var stocks = (from c in coarse
            let avg = _stateData.GetOrAdd(c.Symbol, sym => new SelectionData(200))
            where avg.Update(cf.EndTime, cf.AdjustedPrice)
            where c.DollarVolume > 1000000000 &&
                  c.Price > avg.Ema
            orderby c.DollarVolume descending
            select c.Symbol).Take(10).ToList();
        return stocks;
    }
</pre>
<pre class="python">
    def MyCoarseFilterFunction(self, coarse):
        # We are going to use a dictionary to refer the object that will keep the moving averages
        for cf in coarse:
            if cf.Symbol not in self.stateData:
                self.stateData[cf.Symbol] = SelectionData(cf.Symbol, 200)

            # Updates the SymbolData object with current EOD price
            avg = self.stateData[cf.Symbol]
            avg.update(cf.EndTime, cf.AdjustedPrice, cf.DollarVolume)

        # Filter the values of the dict: we only want up-trending securities
        values = list(filter(lambda x: x.is_above_ema, self.stateData.values()))
        
        # sort by the largest in volume.
        values.sort(key=lambda x: x.volume, reverse=True)

        # we need to return only the symbol objects
        return [ x.symbol for x in values[:10] ]
</pre>
</div>
<p>
In this example we've used a <code>SelectionData</code> class. This is a tidy way to group together variables for our universe selection and update any indicators all in a few lines of  code. We highly recommend following this pattern to keep your algorithm tidy and bug free! Below we've put an example of a SelectionData class but you can make this whatever you need to store your custom universe filters.
</p>
<div class="section-example-container">
<pre class="python">
class SelectionData(object):
    def __init__(self, symbol, period):
        self.symbol = symbol
        self.ema = ExponentialMovingAverage(period)
        self.is_above_ema = False
        self.volume = 0

    def update(self, time, price, volume):
        self.volume = volume
        if self.ema.Update(time, price):
            self.is_above_ema = price > ema
</pre>
<pre class="csharp">
// example selection data class
private class SelectionData
{
    // variables you need for selection
    public readonly ExponentialMovingAverage Ema;

    // initialize your variables and indicators.
    public SelectionData(int period)
    {
        Ema = new ExponentialMovingAverage(period);
    }

    // update your variables and indicators with the latest data.
    // you may also want to use the History API here.
    public bool Update(DateTime time, decimal value)
    {
        return Ema.Update(time, value);
    }
}
</pre>
</div>

<h4>Example 3: Take top 10 "fastest moving" stocks with a 50-Day EMA > 200 Day EMA.</h4>
<p>
Complex universe filters can be constructed using the SelectionData helper class pattern. We have implemented a full example of this case in Github which you can view 
<span class="csharp"><a href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.CSharp/EmaCrossUniverseSelectionAlgorithm.cs" target="_BLANK">here</a></span>
<span class="python"><a href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.Python/EmaCrossUniverseSelectionAlgorithm.py" target="_BLANK">here</a></span>.
</p>