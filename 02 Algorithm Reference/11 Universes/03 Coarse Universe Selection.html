<meta name="tag" content="universes" />
<meta name="tag" content="coarse universes" />

<p>
Coarse Universe selection allows you to pick a set of stocks by its volume, price or whether it has fundamental data. This is helpful to narrow down your universe to liquid assets, or assets which pass a technical indicator filter.
</p>

<p>
To use a coarse universe you must request it using an $[AddUniverse(), M:QuantConnect.Algorithm.QCAlgorithm.AddUniverse] call from the Initialize() method of your algorithm. You should pass in a function which will be used to filter the stocks down to the assets you are interested in using.
</p>
<div class="section-example-container" >
<pre class="csharp">
public class MyCoarseUniverseAlgorithm : QCAlgorithm {
    public override void Initialize() {
        AddUniverse(MyCoarseFilterFunction);
    }
    // Coarse Filter Function accepts a list of CoarseFundamental Objects. 
    IEnumerable&lt;Symbol&gt; MyCoarseFilterFunction(IEnumerable&lt;CoarseFundamental&gt; coarse) {
         
    }
}
</pre>
<pre class="python">
class MyCoarseUniverseAlgorithm(QCAlgorithm):
     def Initialize(self):
         self.AddUniverse(self.MyCoarseFilterFunction)

    def MyCoarseFilterFunction(self, coarse):
         pass
</pre>
</div>

<p>
The coarse filter function is provided a list of $[CoarseFundamental,T:QuantConnect.Data.UniverseSelection.CoarseFundamental] objects. The most important properties of this object are: <code>Price</code>, <code>DollarVolume</code> and <code>HasFundamentaData</code>. Typical examples of filter functions you might want sound like: 
</p>
<h4>Example 1: Take 500 stocks worth more than $10, with more than $10M daily trading volume.</h4>
<p>
The most common use case is selecting a lot of liquid stocks. With coarse this is simple and fast. This example below of a coarse filter function selects the top most liquid 500 stocks over $10 per share.
</p>
<div class="section-example-container" >
<pre class="csharp">
    IEnumerable&lt;Symbol&gt; MyCoarseFilterFunction(IEnumerable&lt;CoarseFundamental&gt; coarse) {
        // Linq makes this a piece of cake;
        var stocks = (from c in coarse
            where c.DollarVolume > 10000000 &&
                  c.Price > 10
            orderby c.DollarVolume descending
            select c.Symbol).Take(500).ToList();
        return stocks;
    }
</pre>
<pre class="python">
    def MyCoarseFilterFunction(self, coarse):
         sortedByDollarVolume = sorted(coarse, key=lambda x: x.DollarVolume, reverse=True)
         filtered = [ x.Symbol for x in sortedByDollarVolume 
                      if x.Price > 10 and x.DollarVolume > 10000000 ]
         return filtered[:500]
</pre>
</div>


<h4>Example 2: Take 10 stocks above their 200-Day EMA with more than $1B daily trading volume.</h4>
<p>
Another common request is to filter the universe by a technical indicator, such as only picking those above their 200-day EMA. The coarse fundamental object has adjusted price and volume information so we can do any price related analysis and return the symbols which pass our filter. A single indicator is relatively simple to do with a basic dictionary of Symbols to Indicator. 
</p>
<div class="section-example-container" >
<pre class="csharp">
    Dictionary&lt;Symbol, ExponentialMovingAverage&gt 
        SelectionData = new Dictionary&lt;Symbol, ExponentialMovingAverage&gt();

    IEnumerable&lt;Symbol&gt; MyCoarseFilterFunction(IEnumerable&lt;CoarseFundamental&gt; coarse) {
        // Linq makes this a piece of cake;
        var stocks = (from c in coarse
            where c.DollarVolume > 10000000 &&
                  c.Price > 10
            orderby c.DollarVolume descending
            select c.Symbol).Take(500).ToList();
        return stocks;
    }
</pre>
<pre class="python">
    def MyCoarseFilterFunction(self, coarse):
         sortedByDollarVolume = sorted(coarse, key=lambda x: x.DollarVolume, reverse=True)
         filtered = [ x.Symbol for x in sortedByDollarVolume 
                      if x.Price > 10 and x.DollarVolume > 10000000 ]
         return filtered[:500]
</pre>
</div>


<h4>Example 3: Take stocks with a 50-Day EMA > 200 Day EMA, and average volume greater than $10M.</h4>
<p>
For more complex universe queries you should create a small class to hold all of the variables associated with your decision. This helps keep your code tidy and makes it easier to debug, This class will save the state of your variables.
</p>
<div class="section-example-container" >
<pre class="csharp">
    class CustomState {
            public Symbol Symbol;
            public ExponentialMovingAverage Slow;
            public ExponentialMovingAverage Fast;
            public SimpleMovingAverage Volume;
            public CustomState(Symbol symbol) {
                  Symbol = symbol;
                  Slow = new ExponentialMovingAverage(200);
                  Fast = new ExponentialMovingAverage(50);
                  Volume = new SimpleMovingAverage(20);
            }
    }
</pre>
<pre class="python">
    class CustomState(object):
          def __init__(self, symbol):
              self.symbol = symbol
              this.slow = ExponentialMovingAverage(200)
              this.fast = ExponentialMovingAverage(50)
              this.volume = SimpleMovingAverage(20)
</pre>
</div>
<p>With this we can perform stateful universe selection, fetching and updating the indicator values each day.</p>