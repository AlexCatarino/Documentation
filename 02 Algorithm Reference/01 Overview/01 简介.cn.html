<meta name="tag" content="using quantconnect">
<p>	 		
	QuantConnect的LEAN引擎管理您的投资组合和数据传输，让您专注于您的算法策略和执行。数据通过事件处理程序传输到您的策略中，您可以在其内进行交易。我们自动提供基本的投资组合管理和模型填充。这是由 $[QCAlgorithm,T:QuantConnect.Algorithm.QCAlgorithm]基础类别提供的。
</p>
<p>
	所有算法都扩展了 $[QCAlgorithm,T:QuantConnect.Algorithm.QCAlgorithm]，它提供了一些关键辅助属性供您使用：证券管理器(Security Manager)，资产组合管理器(Portfolio Manager)，交易管理器(Transactions Manager)，通知管理器(Notification Manager)和预约管理器(Scheduling Manager)。这些辅助属性与数百种辅助方法一起使API易于使用。我们将在接下来的几节中详细介绍。
</p>
<p>
	证券$[(Securities),P:QuantConnect.Algorithm.QCAlgorithm.Securities]<span class="csharp fsharp python">属性</span>是证券(Security)对象的字典。您算法中的每个资产（权益，外汇等）都有一个证券对象。一个证券的所有模型都存在于这些对象上：例如&nbsp;<span class="csharp fsharp">
<code>Securities["IBM"].FeeModel</code>或者<code>Securities["IBM"].Price</code>.
</span><span class="python"><code>self.Securities["IBM"].FeeModel</code>或者<code>self.Securities["IBM"].Price</code>.
</span>
</p>
<p>
	资产组合$[(Portfolio),P:QuantConnect.Algorithm.QCAlgorithm.Portfolio]是证券持有(SecurityHolding)类别的字典。这些类别跟踪记录个别投资组合项目的盈亏，费用和持有数量。例如
	<code class="csharp fsharp">Portfolio["IBM"].LastTradeProfit</code>
	<code class="python">self.Portfolio["IBM"].LastTradeProfit</code>。
</p>
<p>
	其它辅助属性如交易$[(Transactions),P:QuantConnect.Algorithm.QCAlgorithm.Transactions]，预约$[(Schedule),P:QuantConnect.Algorithm.QCAlgorithm.Schedule]，通知$[(Notify),P:QuantConnect.Algorithm.QCAlgorithm.Notify]，和资产集$[(Universe),P:QuantConnect.Algorithm.QCAlgorithm.Universe]都有自己的辅助方法，我们将在接下来的章节中介绍。
</p>

<div class="section-example-container">
<pre class="csharp">public class QCAlgorithm
{
        SecurityManager Securities;   //证券对象的数组(Array of Security objects)
        SecurityPortfolioManager Portfolio;  // 证券持有对象的数组(Array of SecurityHolding objects)
        SecurityTransactionManager Transactions;  // 交易助手（Transactions helper）
        ScheduleManager Schedule;  // 预约助手(Scheduling helper)
        NotificationManager Notify; // 邮件，短信助手(Email, SMS helper)
        UniverseManager Universe; // 资产集助手(Universe helper)

        //设置需要的数据，资金，交易时间段
        public virtual void Initialize() { ... };

        //时间处理程序
        public virtual OnData(Slice data) { ... };
        public virtual OnDividend() { ... };
        public virtual OnEndOfDay() { ... };
        public virtual OnEndOfAlgorithm() { ... };

        //指标助手
        public SimpleMovingAverage SMA();
}</pre>
<pre class="python">def QCAlgorithm
{
        self.Securities;   # 证券对象的数组(Array of Security objects)
        self.Portfolio;    # 证券持有对象的数组(Array of SecurityHolding objects)
        self.Transactions; # 交易助手（Transactions helper）
        self.Schedule;    # 预约助手(Scheduling helper)
        self.Notify;      # 邮件，短信助手(Email, SMS helper)
        self.Universe;    # 资产集助手(Universe helper)

        # 设置需要的数据，资金，交易时间段
        def Initialize:

        # 时间处理程序
        def OnData(self, slice):
        def OnEndOfDay(self, symbol):
        def OnEndOfAlgorithm():

        # 指标助手
        def SMA():
}</pre>
</div>
