<style>
.work-in-progress {
    width: 100%;
    border: 1px solid #f5ae29;
    border-radius: 5px;
    padding: 15px;
    color: #f5ae29;
}
.tip {
    width: 100%;
    border: 1px solid #f5ae29;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 20px;
    margin-top: 20px;
}
.tip i {
    color: #f5ae29;
}
.tip-title { 
 font-weight: bold;
color: #f5ae29;
margin-left: 5px;
margin-right: 5px;
}
.tip p { display: inline; }
table th i {
    color: #f5ae29;
}
th.summary {
   font-family: "Courier New"; 
   font-weight: normal;
}
.table.qc-table tbody tr td {
   text-align: left;
}
.implementation {
    font-family: "Courier New";
}
</style>

<p>The historical data API has many different options to give you the greatest flexibility in how to apply it to your algorithm.</p>


<h4>Request Options</h4>
<p>You can request historical data based on a trailing number of bars or period of time.</p>

<h4>Return Formats</h4>
<p>Each asset class supports slightly different data formats. When you make a history request, consider what data returns. <span class="python">Depending on how you request the data, history requests return a DataFrame or Slice objects.</span><span class="csharp">Depending on how you request the data and the data that's available for your security, history requests return <code>TradeBars</code>, <code>QuoteBars</code>, or <code>Slice</code> objects.</span>. The <code>History</code> API holds to the following rules:</p> 

<ul>
    <li class="csharp">If you request data for a single security, you get an array of the security data type (for example,<code> TradeBar[]</code>).</li>
    <li class="csharp">If you request data for multiple securities, you get an array of <code>Slice</code> objects.</li>

    <li class="python">If you provide <code>Symbol</code> objects, you get a DataFrame.</li>
    <li>If you don't provide Symbol objects, you get <code>Slice</code> objects that contain the entire universe.</li> 
</ul>


<h4>Time Index</h4>

<p>The data that a history request returns is indexed by the <code>EndTime</code> of each data point. For daily data, this results in data points appearing on Saturday and skipping Monday.</p>
