<p>The simplest form of history request is for a known set of <code>Symbol</code> objects. This is common for fixed universes of securities or when you need to prepare new securities added to your algorithm. <span class="csharp">History requests return slightly different data depending on the overload you call.</span>
</p>

<p>Historical data is in ascending order from oldest to newest. This order is necessary to use the data to warm up indicators.</p>

<h4>Single Symbol History Requests</h4>

<p class="python">
History requests for a known set of <code>Symbol</code> objects return a DataFrame. Each row of the DataFrame represents the prices at a point of time. Each column of the DataFrame is a property of that price data (for example, open, high, low, and close). 
</p>

<p class="csharp">When you request data for a single <code>Symbol</code>, LEAN can infer the type of the returning data is fixed and directly returns an array of bars.</p>

<div class="section-example-container">
<pre class="python"><b># EXAMPLE 1: Requesting By Bar Count: 5 IBM TradeBars, defaulting to security resolution:</b>
symbol = self.AddEquity("IBM", Resolution.Daily).Symbol
self.df = self.History(symbol, 5)
<img class="img-responsive img-thumbnail " src="https://cdn.quantconnect.com/docs/i/history-dataframe-tradebars-single_rev0.png">
</pre>
<pre class="python"><b># EXAMPLE 2: Requesting By Bar Count: 5 IBM Minute TradeBars:</b>
self.df = self.History(symbol, 5, Resolution.Minute)
<img class="img-responsive img-thumbnail " src="https://cdn.quantconnect.com/docs/i/history-dataframe-tradebars-single-minute_rev0.png">
</pre>
<pre class="python"><b># EXAMPLE 3: Requesting By Period: 1 Week IBM TradeBars, defaulting to security resolution:</b> 
self.df = self.History(symbol, timedelta(7)) 
<img class="img-responsive img-thumbnail " src="https://cdn.quantconnect.com/docs/i/history-dataframe-period-daily_rev0.png">
# Imporant Note: April 19th is Easter Friday, which has a bar EndTime = 20th, is not present.
</pre>
<pre class="python"><b># EXAMPLE 4: Requesting By Period: 5 Minutes IBM TradeBars:</b> 
self.df = self.History(symbol, timedelta(5), Resolution.Minute)
<img class="img-thumbnail img-responsive" src="https://cdn.quantconnect.com/docs/i/history-dataframe-period-minute_rev0.png">
# Important Note: Period history requests are relative to "now" algorithm time. The example above would return 5 minute bars if requested *at* market close. If you wait for 16.05 it will return nothing.
</pre>

<pre class="csharp"><b>// Single Symbol History Method Arguments: </b>
var bars = History&lt;Type&gt;(Symbol symbol, int barCount, Resolution resolution = null);
var bars = History&lt;Type&gt;(Symbol symbol, TimeSpan period, Resolution = null);
</pre>
<pre class="csharp"><b>// EXAMPLE 1: 100 Bars of Single Symbol, Specifying Type, Default to Security Resolution:</b>
var ibm = AddEquity("IBM", Resolution.Minute).Symbol;
var bars = History&lt;TradeBar&gt;(ibm, 100);

// Same request but for QuoteBars
var eurusd = AddForex("EURUSD", Resolution.Minute).Symbol;
var quoteBars = History&lt;QuoteBar&gt;(eurusd, 100);
</pre>
<pre class="csharp"><b>// EXAMPLE 2: Six Hours of Bars of Single Symbol, Setting Resolution:</b>
var bars = History&lt;TradeBar&gt;(ibm, TimeSpan.FromHours(6), Resolution.Minute);

// Same request but for QuoteBars
var quoteBars = History&lt;QuoteBar&gt;(eurusd, TimeSpan.FromHours(6), Resolution.Minute);
</pre>

</div>

<h4>Multiple Symbol History Request</h4>
<p>
To request history for multiple symbols at a time, pass an array of Symbol objects to the same API methods shown in the preceding section.
</p>

<p class="csharp">History requests with an array of <code>Symbol</code> objects return an array of <code>Slice</code> objects. This method call provides a container that supports all data types. For example, a history request for Forex <code>QuoteBars</code> and Equity <code>TradeBars</code> has the Forex data under <code>slices.QuoteBars</code> and the Equity data under <code>slices.Bars</code>.</p>

<div class="section-example-container">
<pre class="python"><b># EXAMPLE 5: Multi-Symbol History Request.</b>
ibm = AddEquity("IBM", Resolution.Minute).Symbol;<br>aapl = AddEquity("AAPL", Resolution.Minute).Symbol;
self.df = self.History([ibm, aapl], 2)
<img class="img-responsive img-thumbnail " src="https://cdn.quantconnect.com/docs/i/history-stacked-multi-symbol-python_rev0.png">
</pre>


<pre class="csharp"><b>// Multi-Symbol History Method Arguments:</b>
var slices = History(symbols[], int barCount, Resolution resolution = null);
var slices = History(Symbol[] symbols, TimeSpan period, Resolution = null);
</pre>
<pre class="csharp"><b>// EXAMPLE 1: Symbol array, 5 Bars, Default to Security Resolution:</b>
var ibm = AddEquity("IBM", Resolution.Minute).Symbol;
var aapl = AddEquity("AAPL", Resolution.Minute).Symbol;
var bars = History(new[] { ibm, aapl }, 5);
</pre>
<pre class="csharp"><b>// EXAMPLE 2: Symbol array, 6 Hours, Specifying Resolution:</b>
var bars = History(new[] { ibm, aapl }, TimeSpan.FromHours(6), Resolution.Minute);
</pre>
</div>


<h4>Assumed Default Values</h4>
<p>The following table describes the assumptions made by the History API:</p>
<table class="table qc-table">
    <thead>
        <tr>
            <th>Argument</th>
            <th>Assumption</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Resolution</td>
            <td>LEAN guesses the resolution you request by looking at the securities you already have in your algorithm. If you have a security subscription in your algorithm with a matching Symbol, the history request uses the same resolution at the subscription. If you don't have a security subscription in your algorithm with a matching Symbol, <code>Resolution.Minute</code> is used by default.</td>
        </tr>
        <tr class="csharp">
            <td>Bar type</td>
            <td>If you don't specify a type for the history request, <code>TradeBar</code> is assumed. If the asset you're requesting data for doesn't have TradeBar data, specify the QuoteBar type to receive history.</td>
        </tr>
    </tbody>
</table>
