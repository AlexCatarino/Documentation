<div>What is reality modeling:<br>&nbsp;&nbsp;&nbsp; - In backtesting, the strategy uses historical data to simulate trading decisions that are submited to market conditions.<br>&nbsp;&nbsp;&nbsp; - We try to make it as realistic as possible so the strategy performs as it would have in real-time<br>&nbsp;&nbsp;&nbsp; - We provide basic default models that assume you are trading on highly liquid assets, but if you are trading high volumes or on low volume assets, you should update these models to be more realistic.<br><br>Why is there reality modeling:<br>&nbsp;&nbsp;&nbsp; - We try to make it as realistic as possible so the strategy performs as it would have in real-time<br>&nbsp;&nbsp;&nbsp; - We need to model the behavior of the portfolio, brokerage, fills, slippage, options, and capacity<br>&nbsp;&nbsp;&nbsp; - Models can be used to improve the accuracy of your backtesting&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;QuantConnect endeavors to make our backtesting as realistic as possible <br>by providing high-resolution data, spread information, and powerful <br>transaction models.&nbsp; These models are customizable on a per security <br>basis through setters on the API. <br></div><div><br></div>
<p>
	Models can be used to improve the accuracy of your backtesting. We provide basic default models that assume you are trading on highly liquid assets, but if you are trading high volumes or on low volume assets, you should update these models to be more realistic.
</p>
<p>
	All models are set on a per security basis. To set a model, first fetch the security object and apply your model. 
	</p><div class="section-example-container">	
	<pre class="all">//Set IBM to have a constant $1 transaction fee. 
Securities["IBM"].FeeModel = new ConstantFeeTransactionModel(1); </pre>
</div>
<p></p>
<p>
	All models should be set up in your Initialize() method.
</p>