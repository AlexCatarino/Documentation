<p>Training resources are allocated with a <a target="_BLANK" href="https://en.wikipedia.org/wiki/Leaky_bucket">leaky bucket algorithm</a> where a maximum of n-minutes can be used in a single training, and the allocated compute refills over time. This gives you burst allocations when needed and recharges the allowance to prepare for the next training. Limits are configured by server type according to the table below.
</p>
<p># The training resources are allocated based on a leaky bucket algorithm. If you execute algorithm in QC Cloud, see <a href="/docs/v2/our-platform/organizations/resources#08-Training-Quotas">Training Quotas</a> for more information about training resources. If you execute algorithms locally, the default values for the leaky bucket settings are the following:</p><pre class="c-mrkdwn__pre" data-stringify-type="pre" style="box-sizing: inherit; margin: 4px 0px; padding: 8px; --saf-0:rgba(var(--sk_foreground_low,29,28,29),0.13); font-size: 12px; line-height: 1.50001; font-variant-ligatures: none; white-space: pre-wrap; overflow-wrap: break-word; word-break: normal; tab-size: 4; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace !important; border: 1px solid var(--saf-0); border-radius: 4px; background: rgba(var(--sk_foreground_min,29,28,29),0.04); counter-reset: list-0 0 list-1 0 list-2 0 list-3 0 list-4 0 list-5 0 list-6 0 list-7 0 list-8 0 list-9 0; color: rgb(209, 210, 211); font-style: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;">"scheduled-event-leaky-bucket-capacity" : 2 * 60<br>"scheduled-event-leaky-bucket-time-interval-minutes": 1440<br>"scheduled-event-leaky-bucket-refill-amount": (int)Math.Ceiling(DefaultCapacity/7.0)</pre><p></p><p># To allow virtually unlimited training for local algorithms, add the following key-value pairs to your local configuration file:</p><pre class="c-mrkdwn__pre" data-stringify-type="pre" style="box-sizing: inherit; margin: 4px 0px; padding: 8px; --saf-0:rgba(var(--sk_foreground_low,29,28,29),0.13); font-size: 12px; line-height: 1.50001; font-variant-ligatures: none; white-space: pre-wrap; overflow-wrap: break-word; word-break: normal; tab-size: 4; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace !important; border: 1px solid var(--saf-0); border-radius: 4px; background: rgba(var(--sk_foreground_min,29,28,29),0.04); counter-reset: list-0 0 list-1 0 list-2 0 list-3 0 list-4 0 list-5 0 list-6 0 list-7 0 list-8 0 list-9 0; color: rgb(209, 210, 211); font-style: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;">{
    "scheduled-event-leaky-bucket-capacity": 99999999,
    "scheduled-event-leaky-bucket-time-interval-minutes": 1,
    "scheduled-event-leaky-bucket-refill-amount": 999999,
}</pre><p><br></p>



<p>
Once models are trained you can store the results into an <i>object store</i>. This is a permanent project-specific storage location for data located in QuantConnect. Objects are accessible from backtesting and live, and are stored with a key. You can think of this almost like a private project DropBox for your model data. 
</p>
<p>The object store can be used as a back up of your algorithm variables or to load a complex AI model that you don't wish to re-train. Once stored, your data is backed up on QuantConnect servers until requested.</p>
<p>
When deploying a live algorithm, your state is loaded from the object store on deployment. Currently, it is not "refreshed", so you will need to redeploy the live algorithm when you wish to reload your data.
</p>

<h4>Storing Data</h4>
<p>
The Object Store is accessible in the root of your algorithm. It has the following methods available for storing data. You can see an example of using these in the <a class="csharp" target="_BLANK" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.CSharp/ObjectStoreExampleAlgorithm.cs">demonstration algorithm</a><a class="python" target="_BLANK" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.Python/ObjectStoreExampleAlgorithm.py">demonstration algorithm</a>. 
</p> 

<div class="section-example-container">
<pre class="python">
self.ObjectStore.Save("key", "value")                        # Save data as a string
self.ObjectStore.SaveBytes("key", bytearray(objectValue))    # Save data as a bytes
self.ObjectStore.SaveJson("key", objectValue)                # Save object as JSON encoded string
self.ObjectStore.SaveXml("key", objectValue)                 # Save object as XML encoded string
</pre>
</div>

<h4>Reading Data</h4>
<div class="section-example-container">
<pre class="python">
val = self.ObjectStore.Read("key")                        # Read data as string
bytes = self.ObjectStore.ReadBytes("key")                 # Read data as bytes
jsonObj = self.ObjectStore.ReadJson("key")    # Deserialize a JSON object from storage
xmlObj = self.ObjectStore.ReadXml("key")      # Deserialize a XML object from storage
</pre>
</div>

<h4>Deleting Data</h4>
<p>
You can delete data from the object store using the <code>Delete()</code> method.
</p>
<div class="section-example-container">
<pre class="python">
self.ObjectStore.Delete("key")            # Delete the data from the store
</pre>
</div>


<h4>Storage Limits</h4>
<table class="table qc-table">
<thead>
<tr>
<th width="30%">Subscription Level</th>
<th>Resource Allocation</th>
</tr>
</thead>
<tbody>
<tr><td>Free</td><td>5MB, 100 Files</td></tr>
<tr><td>Prime</td><td>50MB, 1000 Files</td></tr>
<tr><td>Professional</td><td>500MB, 10,000 Files</td></tr>
</tbody>
</table>

## TODO: Redirect to Research Env docs to show how to store models from specific libraries.