<p>The <code>Reader</code> method of your custom data class takes one line of data from the source location and parses it into one of your custom objects. You can add as many properties to your custom data objects as you need, but the following table describes the properties you must set. When there is no usable data in a line, the method should return <code class="csharp">null</code><code class="python">None</code>.</p>

<table class="qc-table table">
    <thead>
        <tr>
            <th>Property</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>Symbol</code></td>
            <td>Set this property to <code>config.Symbol</code></td>
        </tr>
        <tr>
            <td><code>Time</code></td>
            <td>Time of the data sample<br></td>
        </tr>
        <tr>
            <td><code>Value</code></td>
            <td>Default data point value<br></td>
        </tr>
    </tbody>
</table>

<div class="section-example-container">
<pre class="csharp">public class MyCustomDataType : BaseData
{
    public decimal Property1 = 0;
    public string errString = "";

    public override BaseData Reader(
        SubscriptionDataConfig config,
        string line,
        DateTime date,
        bool isLive)
    {
        var data = line.Split(',');
        return new MyCustomDataType()
        {
            // Make sure we only get this data AFTER trading day - don't want look-ahead bias.
            Time = DateTime.ParseExact(data[0], "yyyyMMdd", null).AddHours(20),
            Symbol = config.Symbol,
            Value = Convert.ToDecimal(data[1]),
            Property1 = Convert.ToDecimal(data[2])
        };
    }
}
</pre>
<pre class="python">class MyCustomDataType(PythonData):
    def Reader(self, config, line, date, isLive):
        data = line.split(',')
        custom = MyCustomDataType()
        custom.Symbol = config.Symbol

        # Make sure we only get this data AFTER trading day - don't want look-ahead bias.
        custom.Time = datetime.strptime(data[0], '%Y%m%d') + timedelta(hours=20) 

        custom.Value = float(data[1])
        custom["property1"] = float(data[2])
        return custom
</pre>
</div>

<p>Your <code>Reader</code> method should return data points in chronological order. If a data point has a timestamp that is the same or earlier than the timestamp of the previous data point, LEAN ignores it.</p>

<p>If your data source returns multiple samples within a single <code>line</code>, follow these steps:</p>

<ol>
    <li>In the <code>GetSource</code> method, pass <code>FileFormat.UnfoldingCollection</code> as the third argument to the <code>SubscriptionDataSource</code> constructor.</li>
    <li>In the <code>Reader</code> method, order the samples by their timestamp and then return a <code>BaseDataCollection(endTime, config.Symbol, objects)</code> where <code>objects</code> is a list of your custom data objects.</li>
</ol>

<div class="section-example-container">
<pre class="python">class MyCustomDataType(PythonData):
    def GetSource(self, config, date, isLiveMode):
        return SubscriptionDataSource("https://raw.githubusercontent.com/DerekMelchin/custom-data-test-2/main/abcd.json", SubscriptionTransportMedium.RemoteFile, FileFormat.UnfoldingCollection)

    def Reader(self, config, line, date, isLiveMode):
        objects = []
        data = json.loads(line)
        endTime = None
        for j, i in enumerate(data):
            coin = Bitcoin()
            coin.Symbol = config.Symbol

            ts = int(i['timestamp'])
            coin.Time = datetime.utcfromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')
            coin.EndTime = coin.Time + timedelta(days=1)
            endTime = coin.EndTime

            coin.Value = j

            objects.append(coin)
        return BaseDataCollection(endTime, config.Symbol, objects)</pre>
</div>&nbsp;^ Example: https://www.quantconnect.com/terminal/processCache/?request=embedded_backtest_444c6a94f8dd6f6b538ff6e5466aa0c7.html

<br>
