<p>
	To receive your data in the OnData method, you must create a custom type to instruct LEAN where to get your data and how to read it. All data must extend from $[BaseData,T:QuantConnect.Data.BaseData]
	and override the $[Reader,M:QuantConnect.Data.BaseData.Reader] and $[GetSource,M:QuantConnect.Data.BaseData.Reader] methods.
</p>
<p>
	$[GetSource,M:QuantConnect.Data.BaseData.Reader] instructs LEAN where to find your data. It must return a $[SubscriptionDataSource,T:QuantConnect.Data.SubscriptionDataSource] object
	containing the string URL to find your data, and the format of the data (SubscriptionTransportMedium). When
	the source returned changes URL, the data is downloaded again. This allows LEAN to cache large files and only download new data
	when requested. This also allows you to break up large intraday data into smaller daily files, speeding up the backtest.
</p>

<p>
	$[Reader,M:QuantConnect.Data.BaseData.Reader] takes one line of data provided by the source and parses it into one of your custom objects. In addition to setting your custom type properties, you should also take care to set three required
	properties:
</p>
<ul>
	<li>
		Symbol - Should always be set to config.Symbol
	</li>
	<li>
		Time - Required synchronization of custom data
	</li>
	<li>
		Value - Required for purchasing and portfolio calculations
	</li>
</ul>
<p>-Your reader method should return data points in chronological order. If
 a data point has a timestamp that is the same or earlier than the 
timestamp of the previous data point, it's not injected into your 
algorithm.
	</p><p>When there is no usable data in a line, your type should return <code class="csharp">null</code><code class="python">None</code>. <br></p>

-If your data source returns multiple samples within a single <code>line</code> (like a list with multiple JSON line in it), order the samples by their timestamp and then <code>return BaseDataCollection(endTime, endTime, config.Symbol, data)</code> where <code>data</code> is a list of your custom data type (<code>MyCustomDataType</code> in this case) .
<br>&nbsp;&nbsp;&nbsp;-Example

<div class="section-example-container">
<pre class="csharp">public class MyCustomDataType : BaseData
{
    public decimal Property1 = 0;
    public string errString = "";

    public override SubscriptionDataSource GetSource(
        SubscriptionDataConfig config,
        DateTime date,
        bool isLive)
    {
          return new SubscriptionDataSource("&lt;sourceURLOrPath&gt;", SubscriptionTransportMedium.&lt;enumValue&gt;);
    }

    public override BaseData Reader(
        SubscriptionDataConfig config,
        string line,
        DateTime date,
        bool isLive)
    {
        var data = line.Split(',');
        return new MyCustomDataType()
        {
            // Make sure we only get this data AFTER trading day - don't want look-ahead bias.
            Time = DateTime.ParseExact(data[0], "yyyyMMdd", null).AddHours(20),
            Symbol = config.Symbol,
            Value = Convert.ToDecimal(data[1]),
            Property1 = Convert.ToDecimal(data[2])
        };
    }
}
</pre>
<pre class="python">class MyCustomDataType(PythonData):
    def GetSource(self, config, date, isLive):
        return SubscriptionDataSource("&lt;sourceURLOrPath&gt;", SubscriptionTransportMedium.&lt;enumValue&gt;);

    def Reader(self, config, line, date, isLive):
        data = line.split(',')
        custom = MyCustomDataType()
        custom.Symbol = config.Symbol

        # Make sure we only get this data AFTER trading day - don't want look-ahead bias.
        custom.Time = datetime.strptime(data[0], '%Y%m%d') + timedelta(hours=20) 

        custom.Value = decimal.Decimal(data[1])
        custom["property1"] = float(data[2])
        return custom
	
class MyAlgorithm(QCAlgorithm):
    def Initialize(self):
        self.symbol = self.AddData(MyCustomDataType, "&lt;name&gt;", Resolution.&lt;enumValue&gt;).Symbol
        
    def OnData(self, data):
        if data.ContainsKey(self.symbol):
            custom_data = data[self.symbol]
            value = custom_data.Value
            property1 = custom_data.GetProperty('property1')
</pre>
</div><div>^ TODO: Update the C# algorithm to include a demo of accessing the data in OnData<br></div><div><br></div><div>

You can even change source locations for backtesting and live modes. We support many different data types and formats. The following sections describe each response type.
</div><h4>Local Files</h4>
<p>
When you use $[SubscriptionTransportMedium.LocalFile,T:QuantConnect.SubscriptionTransportMedium], the subscription's data comes from your local disk.
</p>

<div class="section-example-container">
<pre class="csharp">return new SubscriptionDataSource("&lt;filePath&gt;", SubscriptionTransportMedium.LocalFile);</pre>
<pre class="python">return SubscriptionDataSource("&lt;filePath&gt;", SubscriptionTransportMedium.LocalFile)</pre>
</div>

<h4>Remote Files</h4>
<p>
When you use $[SubscriptionTransportMedium.RemoteFile,T:QuantConnect.SubscriptionTransportMedium], the subscription's data is downloaded from a remote source.
</p>

<div class="section-example-container">
<pre class="csharp">return new SubscriptionDataSource("&lt;sourceURL&gt;", SubscriptionTransportMedium.RemoteFile);</pre>
<pre class="python">return SubscriptionDataSource("&lt;sourceURL&gt;", SubscriptionTransportMedium.RemoteFile)</pre>
</div>

<h4>REST API</h4>
<p>
When you use $[SubscriptionTransportMedium.Rest,T:QuantConnect.SubscriptionTransportMedium], he subscription's data comes from a rest call that is polled and returns a single line/data point of information. The URL provided is polled at each Resolution time step and is assumed to be sufficient for 1-data point. This is generally intended for live data sources.
</p>

<div class="section-example-container">
<pre class="csharp">return new SubscriptionDataSource("&lt;sourceURL&gt;", SubscriptionTransportMedium.Rest);</pre>
<pre class="python">return SubscriptionDataSource("&lt;sourceURL&gt;", SubscriptionTransportMedium.Rest)</pre>
</div>

<h4>Streaming Sources</h4>
<p>
When you use $[SubscriptionTransportMedium.Streaming,T:QuantConnect.SubscriptionTransportMedium], the subscription's data is streamed. This is generally intended for live data sources.
</p>

<div class="section-example-container">
<pre class="csharp">return new SubscriptionDataSource("&lt;sourceURL&gt;", SubscriptionTransportMedium.Streaming);</pre>
<pre class="python">return SubscriptionDataSource("&lt;sourceURL&gt;", SubscriptionTransportMedium.Streaming)</pre>
</div>



<h4>response type </h4>
<p>what it means and 1-liner on how to use it.</p>