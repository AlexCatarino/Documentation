<div>The Universe Selection Model is in charge of selecting assets, so you should not assume any fixed set of assets. When assets are added to or removed from your universe, they will trigger an { OnSecuritiesChanged()} event. From there, you can initialize any state or history required for your Portfolio Construction Model.&nbsp;</div><div><br></div>



<div class="section-example-container">
		<pre class="csharp">class MyPortfolioConstructionModel : PortfolioConstructionModel
{
    void OnSecuritiesChanged(QCAlgorithmFramework algorithm, SecurityChanges changes)
    {
        base.OnSecuritiesChanged(algorithm, changes);
        foreach (var security in changes.AddedSecurities)
        {               
            _symbolDataBySymbol[security.Symbol] = new SymbolData(security.Symbol);
        }

        foreach (var security in changes.RemovedSecurities)
        {
            if (_symbolDataBySymbol.ContainsKey(security.Symbol))
            {
                _symbolDataBySymbol[security.Symbol].dispose();
                _symbolDataBySymbol.Remove(security.Symbol);
            }
        }
    }

    public class SymbolData 
    {
        private Symbol _symbol;

        public SymbolData(Symbol symbol)
        {
            _symbol = symbol;
            // Store and manage Symbol-specific data
        }
    }
}</pre>
		<pre class="python">class MyPortfolioConstructionModel(PortfolioConstructionModel):
    symbol_data_by_symbol = {}

    def OnSecuritiesChanged(self, algorithm, changes):
        super().OnSecuritiesChanged(algorithm, changes)
        for security in changes.AddedSecurities:
            self.symbol_data_by_symbol[security.Symbol] = SymbolData(security.Symbol)

        for security in changes.RemovedSecurities:
            if security.Symbol in self.symbol_data_by_symbol:
                self.symbol_data_by_symbol.pop(security.Symbol, None)

class SymbolData:
    def __init__(self, symbol):
        self.symbol = symbol
        # Store and manage Symbol-specific data</pre>
	</div>

