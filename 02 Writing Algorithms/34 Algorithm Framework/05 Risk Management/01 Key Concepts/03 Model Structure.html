<p>
The Risk Management Model should extend the RiskManagementModel class and has one required method: $[ManageRisk(),M:QuantConnect.Algorithm.Framework.Risk.IRiskManagementModel.ManageRisk], which receives an array of $[PortfolioTarget,T:QuantConnect.Algorithm.Framework.Portfolio.IPortfolioTarget] objects. When an adjustment of the targets is required, you should return the <i>changed</i> targets only. Optionally you can also use the $[OnSecuritiesChanged(),M:QuantConnect.Algorithm.Framework.Risk.RiskManagementModel.OnSecuritiesChanged] event.
</p>
<div class="section-example-container">
	<pre class="csharp">class MyRiskManagementModel : RiskManagementModel
{
    // Adjust the portfolio targets and return them. If no changes emit nothing.
    List&lt;PortfolioTarget&gt; ManageRisk(QCAlgorithmFramework algorithm, PortfolioTarget[] targets)      {
    }

    // Optional: Be notified when securities change
    void OnSecuritiesChanged(QCAlgorithmFramework algorithm, SecurityChanges changes)
    {
    }
}</pre>
	<pre class="python">class MyRiskManagementModel(RiskManagementModel):
    # Adjust the portfolio targets and return them. If no changes emit nothing.
    def ManageRisk(self, algorithm, targets):
        return []

    # Optional: Be notified when securities change
    def OnSecuritiesChanged(self, algorithm, changes):
        pass
</pre>
</div>

- The `algorithm` passed to each of the components is the base QCAlgorithm class, not your subclass of it
