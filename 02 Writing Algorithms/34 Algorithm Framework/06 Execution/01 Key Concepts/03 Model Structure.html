<p>The Execution Model should extend the ExecutionModel class and has one required method to implement $[Execute(algorithm, targets),M:QuantConnect.Algorithm.Framework.Execution.ExecutionModel.Execute], which receives&nbsp; an array of $[PortfolioTarget,T:QuantConnect.Algorithm.Framework.Portfolio.PortfolioTarget] objects and is responsible for reaching the target portfolios as efficiently as possible. The <a href="https://www.quantconnect.com/docs/algorithm-framework/portfolio-construction" class="docs-internal-link">Portfolio Construction Model</a> creates the PortfolioTarget objects and then the <a href="https://www.quantconnect.com/docs/algorithm-framework/risk-management" class="docs-internal-link">Risk Management Model </a>may adjust them. The Execution Model receives the final risk-adjusted portfolio targets for fulfillment.
</p>
<div class="section-example-container">
	<pre class="csharp"> // Basic Execution Model Scaffolding Structure Example
class MyExecutionModel : ExecutionModel {

   // Fill the supplied portfolio targets efficiently.
   public override void Execute(QCAlgorithmFramework algorithm, IPortfolioTarget[] targets)
   {
      // NOP
   }

   //  Optional: Securities changes event for handling new securities.
   public override void OnSecuritiesChanged(QCAlgorithmFramework algorithm,
                                            SecurityChanges changes)
   {
   }
}</pre>
	<pre class="python">from clr import AddReference
AddReference("QuantConnect.Algorithm.Framework")
from QuantConnect.Algorithm.Framework.Execution import ExecutionModel

# Execution Model scaffolding structure example
class MyExecutionModel(ExecutionModel):

    # Fill the supplied portfolio targets efficiently
    def Execute(self, algorithm, targets):
        pass

    # Optional: Securities changes event for handling new securities.
    def OnSecuritiesChanged(self, algorithm, changes):
        pass</pre>
</div>
<p>- The `algorithm` passed to each of the components is the base QCAlgorithm class, not your subclass of it</p><p>The $[PortfolioTarget,T:QuantConnect.Algorithm.Framework.Portfolio.IPortfolioTarget] class has the following properties available for use by the Execution Model. They can be accessed with their public properties <code>target.Quantity</code>.
</p>
<div class="section-example-container">
	<pre class="csharp">// Final target quantity for execution
class PortfolioTarget : IPortfolioTarget {

    // Asset to be traded.
    Symbol Symbol;

    // Number of units to hold.
    decimal Quantity;
}</pre>
	<pre class="python"># Final target quantity for execution
class PortfolioTarget:
    self.Symbol    # Asset to be traded (Symbol object)
    self.Quantity  # Number of units to hold (Decimal)</pre>
</div>
