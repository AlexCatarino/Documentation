
<div>The standard OptionUniverseSelectionModel selects all the available contracts for the Options you specify. The constructor accepts the following arguments: <br></div><div>- refreshInterval: Time interval between universe refreshes</div><div>- optionChainSymbolSelector: A function that accepts an UTC datetime object and returns a list of Option Symbol objects. This function selects symbols from the provided option chain<br></div><div>- (optional) universeSettings: Universe settings define attributes of created subscriptions, such as their resolution and the minimum time in universe before they can be removed. If you don't provide one, it uses the algorithm UniverseSettings.</div><div><br></div><div class="section-example-container">
	<pre class="csharp">public override void Initialize()
{
    AddUniverseSelection(
        new OptionUniverseSelectionModel(TimeSpan.FromDays(1), SelectOptionChainSymbols)
    );
}

private static IEnumerable&lt;Symbol&gt; SelectOptionChainSymbols(DateTime utcTime)
{
    var tickers = new[] {"SPY", "QQQ", "TLT"};
    return tickers.Select(ticker => QuantConnect.Symbol.Create(ticker, SecurityType.Option, Market.USA));
}</pre>
	<pre class="python">from Selection.OptionUniverseSelectionModel import OptionUniverseSelectionModel 

def Initialize(self):
    universe = OptionUniverseSelectionModel(timedelta(days=1), self.option_chain_symbol_selector)
    self.SetUniverseSelection(universe)

def option_chain_symbol_selector(self, utc_time):
    tickers = ["SPY", "QQQ", "TLT"]
    return [Symbol.Create(ticker, SecurityType.Option, Market.USA) for ticker in tickers]</pre>
</div>

- If you want to use a different filter for the contracts, subclass the OptionUniverseSelectionModel and define a Filter method. The Filter method should accept and return a OptionFilterUniverse object. For a full example, see the <a href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.Python/BasicTemplateOptionsFrameworkAlgorithm.py">BasicTemplateOptionsFrameworkAlgorithm</a>.