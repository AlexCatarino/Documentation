<div>The standard FutureUniverseSelectionModel selects the contracts that expire within 35 days for the Futures that you specify. The constructor accepts the following arguments: <br></div><div>- refreshInterval: Time interval between universe refreshes</div><div>- futureChainSymbolSelector: A function that accepts an UTC datetime object and returns a list of Future Symbol objects. <br></div><div>- (optional) universeSettings: The universe settings, if none it uses the algorithm UniverseSettings.</div><div><br></div><div class="section-example-container">
	<pre class="csharp">public override void Initialize()
{
    AddUniverseSelection(
        new FutureUniverseSelectionModel(TimeSpan.FromDays(1), SelectFutureChainSymbols)
    );
}

private static IEnumerable&lt;Symbol&gt; SelectFutureChainSymbols(DateTime utcTime)
{
    return new[] {
        QuantConnect.Symbol.Create(Futures.Indices.SP500EMini, SecurityType.Future, Market.CME),
        QuantConnect.Symbol.Create(Futures.Metals.Gold, SecurityType.Future, Market.COMEX)
    };
}</pre>
	<pre class="python">from Selection.FutureUniverseSelectionModel import FutureUniverseSelectionModel

def Initialize(self):
    universe = FutureUniverseSelectionModel(timedelta(days=1), self.future_chain_symbol_selector)
    self.SetUniverseSelection(universe)

def future_chain_symbol_selector(self, utc_time):
    return [ Symbol.Create(Futures.Indices.SP500EMini, SecurityType.Future, Market.CME),
             Symbol.Create(Futures.Metals.Gold, SecurityType.Future, Market.COMEX) ]</pre>
</div>

- If you want to use a different filter for the contracts, subclass the FutureUniverseSelectionModel and define a Filter method. The Filter method should accept and return a FutureFilterUniverse object. For a full example, see the <a href='https://github.com/QuantConnect/Lean/blob/master/Algorithm.Python/BasicTemplateFuturesFrameworkAlgorithm.py'>BasicTemplateFuturesFrameworkAlgorithm</a>.