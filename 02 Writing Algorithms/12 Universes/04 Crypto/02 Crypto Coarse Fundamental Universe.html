<p>To create a universe of Cryptocurrencies from a single brokerage, add a <code>CryptoCoarseFundamentalUniverse</code> universe. You need to provide the Crypto market, some universe settings, and a universe filter function.</p>

<div class="section-example-container">
<pre class="python">def Initialize(self):
    self.UniverseSettings.Resolution = Resolution.Daily
    self.SetBrokerageModel(BrokerageName.GDAX, AccountType.Cash)

    # Add universe selection of cryptos based on coarse fundamentals
    self.AddUniverse(CryptoCoarseFundamentalUniverse(Market.GDAX, self.UniverseSettings, self.UniverseSelectionFilter))

def UniverseSelectionFilter(self, crypto_coarse):
    # Define the universe selection function
    return [cf.Symbol for cf in crypto_coarse if cf.Volume &gt;= 100 and cf.VolumeInUsd &gt; 10000]</pre>
<pre class="csharp">public override void Initialize()
{
    UniverseSettings.Resolution = Resolution.Daily;
    SetBrokerageModel(BrokerageName.GDAX, AccountType.Cash);

    // Add universe selection of cryptos based on coarse fundamentals
    AddUniverse(new CryptoCoarseFundamentalUniverse(Market.GDAX, UniverseSettings, UniverseSelectionFilter));
}

private IEnumerable&lt;Symbol&gt; UniverseSelectionFilter(IEnumerable&lt;CryptoCoarseFundamental&gt; cryptoCoarse)
{
    return cryptoCoarse.Where(cf =&gt; cf.Volume &gt;= 100m &amp;&amp; cf.VolumeInUsd &gt; 10000m).Select(x =&gt; x.Symbol);
}</pre>
</div>

<p>To analyze Crypto assets from multiple markets, add multiple universes, each with a different Market argument.</p>


<p><code>CryptoCoarseFundamental</code> objects have the following attributes:</p>
<div data-tree="QuantConnect.DataSource.CryptoCoarseFundamental"></div>

<p>In live mode, the pipeline has a 16-hour delay, so the CryptoCoarseFundamental objects are injected into algorithms at around 16:00-16:30 UTC each day, depending on the data processing task.</p>