<p>When you add an Option to an algorithm it adds many individual Option contract securities. LEAN models these contracts as a universe of Option contracts.</p>

<p>To add a universe of Option contracts, in the <code>Initialize</code> method, call the <code>AddOption</code> method.</p>

<div class="section-example-container">
    <pre class="csharp">var option = AddOption("SPY");</pre>
    <pre class="python">option = self.AddOption("SPY")</pre>
</div>

<p>The following table describes the <code>AddOption</code> method arguments:</p>
<table class="qc-table table">
    <thead>
        <tr>
            <th>Argument</th>
            <th>Data Type</th>
            <th>Description</th>
            <th>Default Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>ticker</code></td>
	    <td><code>string</code></td>
            <td>The underlying Equity ticker.</td>
            <td></td>
        </tr>
        <tr>
            <td><code>resolution</code></td>
	    <td><code>Resolution?</code></td>
            <td>The resolution of the market data.</td>
            <td><code class="python">None</code><code class="csharp">null</code></td>
        </tr>
        <tr>
            <td><code>market</code></td>
	    <td><code>string</code></td>
            <td>The underlying Equity market.</td>
            <td><code class="python">None</code><code class="csharp">null</code></td>
        </tr>
        <tr>
            <td><code>fillDataForward</code></td>
	    <td><code>bool</code></td>
            <td>If true, the current slice contains the last available data even if there is no data at the current time.</td>
            <td><code class="python">True</code><code class="csharp">true</code></td>
        </tr>
        <tr>
            <td><code>leverage</code></td>
	    <td><code>decimal</code><br></td>
            <td>The leverage for this Equity.</td>
            <td><code>Security.NullLeverage</code></td>
        </tr>
        <tr>
            <td><code>extendedMarketHours</code></td>
	    <td><code>bool</code></td>
            <td>A flag that signals if LEAN should send data during pre- and post-market trading hours.</td>
            <td><code class="python">False</code><code class="csharp">false</code></td>
        </tr>
    </tbody>
</table>


<p>If you add an Option universe for an underlying Equity that you don't have a subscription for, LEAN automatically subscribes to the underlying Equity. By default, LEAN adds all of the available Option contracts to the <a href="/docs/v2/writing-algorithms/key-concepts/time-modeling/timeslices">Slice</a> it passes to the <code>OnData</code> method. To narrow down the universe of Option contracts, call the <code>SetFilter</code> method of the <code>Option</code> object. The following table describes the available filter techniques:</p>


<table class="table qc-table">
    <thead>
        <tr>
            <th>Method<br></th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>SetFilter(int minStrike, int maxStrike)</code></td>
	    <td>Selects the contracts that have a strike price within a minimum and maximum strike level relative to the undelrying price. For example, say the underlying price is $302 and there are strikes at every $5. If you set <code>minStrike</code> to -1 and <code>maxStrike</code> to 1, LEAN selects the contracts that have a strike of $300 or $305. <br></td>
        </tr>
        <tr>
            <td><code>SetFilter(TimeSpan minExpiry, TimeSpan maxExpiry)</code></td>
	    <td>Selects the contracts that expire within the range you set.<br></td>
        </tr>
        <tr>
            <td><code>SetFilter(int minStrike, int maxStrike, TimeSpan minExpiry, TimeSpan maxExpiry)</code></td>
	    <td>Selects the contracts that expire and have a strike within the range you set.</td>
        </tr>
        <tr>
            <td><code>SetFilter(Func&lt;OptionFilterUniverse, OptionFilterUniverse&gt; universeFunc)</code></td>
	    <td>Selects the contracts that a function selects.</td>
        </tr>
    </tbody>
</table>





<div class="section-example-container">
    <pre class="csharp"></pre>
    <pre class="python"># Select contracts that have a strike price within 1 strike level above and below the underlying price
option.SetFilter(minStrike=-1, maxStrike=1)

# Select contracts that expire within 30 days
option.SetFilter(minExpiry=timedelta(days=0), maxExpiry=timedelta(days=30))

# Select contracts that have a strike price within 1 strike level and expire within 30 days
option.SetFilter(minStrike=-1, maxStrike=1, minExpiry=timedelta(days=0), maxExpiry=timedelta(days=30))

# Select call contracts
option.SetFilter(lambda option_filter_universe: option_filter_universe.CallsOnly())
</pre>
</div>



<p>The following table describes the filter methods of the <code>OptionFilterUniverse</code> class:</p>

<?php echo file_get_contents(DOCS_RESOURCES."/universes/option/option-filter-universe.html"); ?>





<p><br></p><div>-Technique 1: AddOption + SetFilter<br></div><div>&nbsp; &nbsp; &nbsp; - Must use raw data normalization<br></div><div>&nbsp; &nbsp; &nbsp; - Save a reference to the canonical Symbol; Explain what canonical Symbol means.<br></div><div>&nbsp; - You can chain universe filters</div><p></p><p>- Option contracts are added to the chain when they pass the SetFilter method criteria. In backtests, contracts are removed from the chain on the NEXT DAY when they no longer satisify the SetFilter method. In live trading, they can be removed every 15 mins.</p><p>&nbsp;&nbsp; - As a result, your chain may have more contracts that you expect at times. See https://github.com/QuantConnect/Lean/issues/6294<br></p>