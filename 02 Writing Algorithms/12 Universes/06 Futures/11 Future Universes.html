<p>To add a universe of Future contracts, in the <code>Initialize</code> method, call the <code>AddFuture</code> method. This method returns an <code>Future</code> object, which contains the canonical <code>Symbol</code>. The canonical <code>Symbol</code> represents the <a href="/docs/v2/writing-algorithms/securities/asset-classes/futures/requesting-data#05-Continuous-Contracts">continuous Future contract</a> and is the key to access the contracts in the <a href="/docs/v2/writing-algorithms/securities/asset-classes/futures/handling-data#04-Futures-Chain">FutureChain</a> that LEAN passes to the <code>OnData</code> method. contracts. When you create the Future subscription, save a reference to the canonical <code>Symbol</code> so you can use it later in your algorithm.</p>

<div class="section-example-container">
    <pre class="csharp">var future = AddFuture(Futures.Currencies.BTC);
_symbol = future.Symbol;</pre>
    <pre class="python">future = self.AddFuture(Futures.Currencies.BTC)
self.symbol = future.Symbol</pre>
</div>

<p>The following table describes the <code>AddFuture</code> method arguments:</p>
<table class="qc-table table">
    <thead>
        <tr>
            <th>Argument</th>
            <th>Data Type</th>
            <th>Description</th>
            <th>Default Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>ticker</code></td>
	    <td><code>string</code></td>
            <td>The Future ticker. To view the supported assets in the US Futures dataset, see <a href="/docs/v2/writing-algorithms/securities/asset-classes/futures/requesting-data#03-Supported-Markets">Supported Markets</a>.<br></td>
            <td></td>
        </tr>
        <tr>
            <td><code>resolution</code></td>
	    <td><code>Resolution?</code></td>
            <td>The resolution of the market data.</td>
            <td><code class="python">None</code><code class="csharp">null</code></td>
        </tr>
        <tr>
            <td><code>market</code></td>
	    <td><code>string</code></td>
            <td>The Futures market. To view the supported markets in the US Futures dataset, see <a href="/docs/v2/writing-algorithms/securities/asset-classes/futures/requesting-data#03-Supported-Markets">Supported Markets</a>.</td>
            <td><code class="python">None</code><code class="csharp">null</code></td>
        </tr>
        <tr>
            <td><code>fillDataForward</code></td>
	    <td><code>bool</code></td>
            <td>If true, the current slice contains the last available data even if there is no data at the current time.</td>
            <td><code class="python">True</code><code class="csharp">true</code></td>
        </tr>
        <tr>
            <td><code>leverage</code></td>
	    <td><code>decimal</code><br></td>
            <td>The leverage for this Future.</td>
            <td><code>Security.NullLeverage</code></td>
        </tr>
        <tr>
            <td><code>dataMappingMode</code></td>
	    <td><code>DataMappingMode?</code></td>
            <td>The contract mapping mode to use for the continuous future contract</td>
            <td><code class="python">None</code><code class="csharp">null</code></td>
        </tr>
        <tr>
            <td><code>dataNormalizationMode</code></td>
	    <td><code>DataNormalizationMode?</code></td>
            <td>The price scaling mode to use for the continuous future contract</td>
            <td><code class="python">None</code><code class="csharp">null</code></td>
        </tr>
        <tr>
            <td><code>contractDepthOffset</code></td>
	    <td><code>int </code></td>
            <td>The continuous future contract desired offset from the current front month. For example, 0 is the front month, 1 is&nbsp; the back month contract.</td>
            <td>0</td>
        </tr>
    </tbody>
</table>



<p>By default, LEAN adds all of the available Future contracts to the <a href="/docs/v2/writing-algorithms/key-concepts/time-modeling/timeslices">Slice</a> it passes to the <code>OnData</code> method. To narrow down the universe of Future contracts, in the <code>Initialize</code> method, call the <code>SetFilter</code> method of the <code>Future</code> object. The following table describes the available filter techniques:</p>

<table class="table qc-table">
    <thead>
        <tr>
            <th>Method<br></th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>SetFilter(int minExpiryDays, int maxExpiryDays)</code></td>
	    <td>Selects the contracts that expire within the range you set.<br></td>
        </tr>
        <tr>
            <td><code>SetFilter(Func&lt;FutureFilterUniverse, FutureFilterUniverse&gt; universeFunc)</code></td>
	    <td>Selects the contracts that a function selects.</td>
        </tr>
    </tbody>
</table>


<div class="section-example-container">
    <pre class="csharp"># Select the contracts which expire within 182 days
future.SetFilter(0, 182)

# Select the front month contract
future.SetFilter(lambda x: x.FrontMonth())</pre>
    <pre class="python">// Select the contracts which expire within 182 days
future.SetFilter(0, 182);

// Select the front month contract
future.SetFilter(x =&gt; x.FrontMonth());
</pre>
</div>

<p>The following table describes the filter methods of the <code>FutureFilterUniverse</code> class:</p>

<table class="qc-table table">
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>StandardsOnly()</code></td>
            <td>Selects standard contracts</td>
        </tr>
        <tr>
            <td><code>IncludeWeeklys()</code></td>
            <td>Selects non-standard weekly contracts</td>
        </tr>
        <tr>
            <td><code>WeeklysOnly()</code></td>
            <td>Selects weekly contracts</td>
        </tr>
        <tr>
            <td><code>FrontMonth()</code></td>
            <td>Selects the front month contract</td>
        </tr>
        <tr>
            <td><code>BackMonths()</code></td>
            <td>Selects the non-front month contracts</td>
        </tr>
        <tr>
            <td><code>BackMonth()</code></td>
            <td>Selects the back month contracts<br></td>
        </tr>
        <tr>
            <td><code>Expiration(<span class="csharp">TimeSpan</span><span class="python">timedelta</span> minExpiry, <span class="csharp">TimeSpan</span><span class="python">timedelta</span> maxExpiry)</code></td>
            <td>Selects contracts that expire within a range of dates relative to the current day<br></td>
        </tr>
        <tr>
            <td><code>Expiration(int minExpiryDays, int maxExpiryDays)</code></td>
            <td>Selects contracts that expire within a range of dates relative to the current day</td>
        </tr>
        <tr>
            <td><code>Contracts(IEnumerable&lt;Symbol&gt; contracts)</code></td>
            <td>Selects a list of contracts</td>
        </tr>
        <tr>
            <td><code>Contracts(Func&lt;IEnumerable&lt;Symbol&gt;, IEnumerable&lt; Symbol&gt;&gt; contractSelector)</code></td>
            <td>Selects contracts that a selector function selects</td>
        </tr>
        <tr>
            <td><code>OnlyApplyFilterAtMarketOpen()</code></td>
            <td>Instructs the engine to only filter contracts on the first time step of each market day</td>
        </tr>
    </tbody>
</table>

<p>The preceding methods return an <code>OptionFilterUniverse</code>, so you can chain the methods together.</p>

<div class="section-example-container">
    <pre class="csharp"></pre>
    <pre class="python"># Select the front month call contracts
future.SetFilter(lambda future_filter_universe: future_filter_universe.StandardsOnly().FrontMonth())</pre>
</div>


<p>To get all of the contracts in the <code>FutureFilterUniverse</code>, call the <code>GetEnumerator</code> method.</p>
<div class="section-example-container">
    <pre class="csharp"></pre>
    <pre class="python"># In Initialize
future.SetFilter(self.contract_selector)
    
def contract_selector(self, future_filter_universe):
    puts = future_filter_universe.StandardsOnly()
    symbols = []
    for _, symbol in enumerate(puts.GetEnumerator()):
        contract = FutureContract(symbol, future_filter_universe.Underlying)
        if contract.OpenInterest &gt; 0: 
            symbols.append(contract.Symbol)
    return future_filter_universe.Contracts(symbols)</pre>
</div>


<p>By default, LEAN adds contracts to the <code>FutureChain</code> that pass the filter criteria at every time step in your algorithm. In backtests, if a contract in the chain doesn't pass the filter criteria, LEAN removes it from the chain at the start of the next day. In live trading, LEAN removes these contracts from the chain every 15 minutes.</p>
