<br>The location in your algorithm where you create and manage the indicators depends on the number of securities in your algorithm.

<h4>Single-Asset Algorithms</h4>

If you only have one security in your algorithm, you can create an automatic indicator in the Initialize method.
<br># Example Code snippet 


<h4>Multi-Asset Algorithms</h4>

<p>If your algorithm has multiple assets or a dynamic universe of assets, abstract your indicator management logic into a separate class.</p>

<div class="section-example-container">
	<pre class="python">class SymbolData:
    def __init__(self, algorithm, symbol):
        self.algorithm = algorithm
	self.symbol = symbol

        # Create an indicator
        self.sma = SimpleMovingAverage(20)

        # Create a consolidator to update the indicator
        self.consolidator = TradeBarConsolidator(1) 
        self.consolidator.DataConsolidated += self.consolidation_handler

        # Register the consolidator to update the indicator
        algorithm.SubscriptionManager.AddConsolidator(symbol, self.consolidator)       

        # Warm up the indicator
        algorithm.WarmUpIndicator(symbol, self.sma)
<br>
    def consolidation_handler(self, sender, consolidated_bar):
        self.sma.Update(consolidated_bar.EndTime, consolidated_bar.Close)


    # If you have a dynamic universe, remove consolidators for the securities removed from the universe
    def dispose(self):
        # Remove the consolidator
        self.algorithm.SubscriptionManager.RemoveConsolidator(self.symbol, self.consolidator)
</pre>
	<pre class="csharp fsharp"></pre>
</div>

<p>Every time a security is added or removed from your universe, create or dispose of the respective <code>SymbolData</code> object in the <code>OnSecuritiesChanged</code> event handler.</p>

<div class="section-example-container">
	<pre class="python">class MyAlgorithm(QCAlgorithm):
    symbol_data_by_symbol = {}

    def OnSecuritiesChanged(self, changes):
        for security in changes.AddedSecurities:
            self.symbol_data_by_symbol[security.Symbol] = SymbolData(self, security.Symbol)

        # If you have a dynamic universe, track removed securities
        for security in changes.RemovedSecurities:
            symbol_data = self.symbol_data_by_symbol.pop(security.Symbol, None)
            if symbol_data:
                symbol_data.dispose()
</pre>
	<pre class="csharp fsharp"></pre>
</div>
