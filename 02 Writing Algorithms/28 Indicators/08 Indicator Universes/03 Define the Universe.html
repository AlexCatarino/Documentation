<p>Define a universe. When your universe function receives coarse/fine objects, create a SymbolData object for each new security, and update the remaining SymbolData objects with their daily price or some other data point attribute. The following universe selects US Equities that have the greatest difference between two moving averages. For more information about universes, see <a href="/docs/v2/writing-algorithms/universes/key-concepts">Universes</a>.<br></p>

<div class="section-example-container">
	<pre class="python">class MyCoarseUniverseAlgorithm(QCAlgorithm):
     def Initialize(self):
         # In addition to other initialization method calls...
         self.symbol_data_by_symbol = {}
         self.coarse_count = 10
         self.AddUniverse(self.CoarseFilterFunction)

    # Sort the data by daily dollar volume and take the top 'coarse_count'
    def CoarseSelectionFunction(self, coarse):

        # Use a dictionary to refer the object that will keep the moving averages
        for c in coarse:
            if c.Symbol not in self.symbol_data_by_symbol:
                self.symbol_data_by_symbol[c.Symbol] = SymbolData(c.Symbol)

            # Update the SymbolData object with the current EOD price
            symbol_data = self.symbol_data_by_symbol[c.Symbol]
            symbol_data.update(c.EndTime, c.AdjustedPrice)

        # Filter the values of the dict: target only want up-trending securities
        values = list(filter(lambda x: x.is_uptrend, self.symbol_data_by_symbol.values()))

        # Sorts the values of the dict: target those with greater difference between the moving averages
        values.sort(key=lambda x: x.scale, reverse=True)

        # Return only the symbol objects
        return [ x.symbol for x in values[:self.coarse_count] ]</pre>
	<pre class="csharp fsharp"></pre>
</div>
