<p>You need to define SymbolData objects before you define the universe that selects securities.</p>

<p>Define a universe. When your universe function receives coarse/fine objects, create a SymbolData object for each new security, and update the remaining SymbolData objects with their daily price or some other data point attribute. The following universe selects US Equities that have the greatest difference between two moving averages. For more information about universes, see <a href="/docs/v2/writing-algorithms/universes/key-concepts">Universes</a>.<br></p>

<div class="section-example-container">
	<pre class="python">class EmaCrossUniverseSelectionAlgorithm(QCAlgorithm):
     def Initialize(self):
         # In addition to other initialization method calls...
         self.selection_data_by_symbol = {}
         self.coarse_count = 10
         self.AddUniverse(self.CoarseFilterFunction)

    # Sort the data by daily dollar volume and take the top 'coarse_count'
    def CoarseSelectionFunction(self, coarse):

        # Use a dictionary to refer the object that will keep the moving averages
        for c in coarse:
            if c.Symbol not in self.selection_data_by_symbol:
                self.selection_data_by_symbol[c.Symbol] = SelectionData(c.Symbol)

            # Update the SymbolData object with the current EOD price
            selection_data = self.selection_data_by_symbol[c.Symbol]
            selection_data.update(c.EndTime, c.AdjustedPrice)

        # Filter the values of the dict: target only want up-trending securities
        values = list(filter(lambda x: x.is_uptrend, self.selection_data_by_symbol.values()))

        # Sorts the values of the dict: target those with greater difference between the moving averages
        values.sort(key=lambda x: x.scale, reverse=True)

        # Return only the symbol objects
        return [ x.symbol for x in values[:self.coarse_count] ]</pre>
	<pre class="csharp">public class EmaCrossUniverseSelectionAlgorithm : QCAlgorithm
{
    // tolerance to prevent bouncing
    const decimal Tolerance = 0.01m;
    private const int Count = 10;
    // holds our coarse fundamental indicators by symbol
    private readonly ConcurrentDictionary<Symbol, SelectionData> _selectionDataBySymbol = new ConcurrentDictionary<Symbol, SelectionData>();

    public override void Initialize()
    {
        // In addition to other initialization method calls...
        AddUniverse(coarse =>
        {
            return (from cf in coarse
                    // grab the SelectionData instance for this symbol
                    let avg = _selectionDataBySymbol.GetOrAdd(cf.Symbol, sym => new SelectionData())
                    // Update returns true when the indicators are ready, so don't accept until they are
                    where avg.Update(cf.EndTime, cf.AdjustedPrice)
                    // only pick symbols who have their 50 day ema over their 100 day ema
                    where avg.Fast > avg.Slow*(1 + Tolerance)
                    // prefer symbols with a larger delta by percentage between the two averages
                    orderby avg.ScaledDelta descending
                    // we only need to return the symbol and return 'Count' symbols
                    select cf.Symbol).Take(Count);
        });
    }
}</pre>
</div>
