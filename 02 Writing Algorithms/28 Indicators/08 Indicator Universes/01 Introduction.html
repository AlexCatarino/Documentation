<p>What is an indicator universe?</p><p>- A universe of securities that you select based on indicator values</p><p><br></p><p>To create an indicator universe, <br></p><p>(1) Define a SymbolData class that contains the selection indicators<br></p>

<div class="section-example-container">
	<pre class="python">class SymbolData(object):
    def __init__(self, symbol):
        self.symbol = symbol
        self.tolerance = 1.01
        self.fast = ExponentialMovingAverage(100)
        self.slow = ExponentialMovingAverage(300)
        self.is_uptrend = False
        self.scale = 0

    def update(self, time, value):
        if self.fast.Update(time, value) and self.slow.Update(time, value):
            fast = self.fast.Current.Value
            slow = self.slow.Current.Value
            self.is_uptrend = fast &gt; slow * self.tolerance

        if self.is_uptrend:
            self.scale = (fast - slow) / ((fast + slow) / 2.0)</pre>
	<pre class="csharp fsharp"></pre>
</div>

<p>Define a universe. When your universe function receives coarse/fine objects, create a SymbolData object for each new security, and update the remaining SymbolData objects with their daily price or some other data point attribute. The following universe selects US Equities that have the greatest difference between two moving averages. For more information about universes, see <a href="/docs/v2/writing-algorithms/universes/key-concepts">Universes</a>.<br></p>

<div class="section-example-container">
	<pre class="python">class MyCoarseUniverseAlgorithm(QCAlgorithm):
     def Initialize(self):
         # In addition to other initialization method calls...
         self.symbol_data_by_symbol = {}
         self.coarse_count = 10
         self.AddUniverse(self.CoarseFilterFunction)

    # Sort the data by daily dollar volume and take the top 'coarse_count'
    def CoarseSelectionFunction(self, coarse):

        # Use a dictionary to refer the object that will keep the moving averages
        for c in coarse:
            if c.Symbol not in self.symbol_data_by_symbol:
                self.symbol_data_by_symbol[c.Symbol] = SymbolData(c.Symbol)

            # Update the SymbolData object with the current EOD price
            symbol_data = self.symbol_data_by_symbol[c.Symbol]
            symbol_data.update(c.EndTime, c.AdjustedPrice)

        # Filter the values of the dict: target only want up-trending securities
        values = list(filter(lambda x: x.is_uptrend, self.symbol_data_by_symbol.values()))

        # Sorts the values of the dict: target those with greater difference between the moving averages
        values.sort(key=lambda x: x.scale, reverse=True)

        # Return only the symbol objects
        return [ x.symbol for x in values[:self.coarse_count] ]</pre>
	<pre class="csharp fsharp"></pre>
</div>
