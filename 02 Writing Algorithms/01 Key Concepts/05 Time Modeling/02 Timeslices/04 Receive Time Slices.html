<p>
    The Slice event handler combines all of the data into a single method. It represents the data at a point in
    time.
    The $[Slice,T:QuantConnect.Data.Slice] object contains many helpers for accessing your data. The Slice objects arrive to the
    <code class="csharp fsharp">OnData(Slice data)</code><code class="python">def OnData(self, slice: Slice)</code> event
    handler. <br></p><p>## TODO: And the slice arrive to the Update method in Alpha models.<br></p>
<p>
    The $[Slice,T:QuantConnect.Data.Slice] object gives you <span class="csharp fsharp">three</span><span class="python">two</span> ways
    to access your data:
</p>
<ul>
    <li>
        Dynamic string/symbol indexer, which returns a dynamic object of your type slice["IBM"].
    </li>
    <li>
        Statically typed properties (slice.Bars[], slice.QuoteBars[]).
    </li>
    <li class="csharp fsharp">
        Statically typed Get&lt;T&gt;() helper
    </li>
</ul>
<p class="csharp fsharp">## TODO: Show example code snippet for each ^<br>
    </p><p class="csharp fsharp">Strongly typed access gives you compile-time safety, but dynamic types can sometimes simplify coding. We recommend
    static
    types as they are easier to debug.
</p>

<p>It contains all the data for a given moment in time. TradeBars and QuoteBars are symbol/string indexed dictionaries
    so you
    can easily access the data. Ticks is a list of ticks for that moment of time, indexed by the symbol.
    To make accessing the data easier the Slice object itself can also be indexed. E.g. <code>slice["IBM"]</code> will
    return a
    <b>TradeBar</b> for IBM, and <code>slice["EURUSD"]</code> will return a <b>QuoteBar</b> for EURUSD. To check which data formats are available for each asset class, see the Data Formats page in the <a href='/docs/v2/writing-algorithms/asset-classes/key-concepts'>Asset Classes</a> chapter. <br></p>
<p>
	Since the Slice object is indexed, it is possible to check if the time slice contains specific data. e.g.
	<code>slice.ContainsKey("EURUSD")</code> will return a boolean. Even if requesting data to be filled forward, you should check 
	if the data exists in the dictionary first. If there is little trading, or you are in the same time loop as when 
	you added the security, it may not have any data.
</p><div>

## TODO: <br></div><div>- Add GetEnumerator</div><div>- if Slice object does not contain a market or custom data, Slice.ContainsKey(Symbol) can return true because auxiliary data is present and Slice[Symbol] will return null/None.<br></div>
