<p>The <code>Slice</code> contains all the data for a given moment in time. The <code>TradeBars</code> and <code>QuoteBars</code> properties are <code>Symbol</code>/string indexed dictionaries. The <code>Ticks</code> property is a list of ticks for that moment of time, indexed by the <code>Symbol</code>. o check which data formats are available for each asset class, see the Data Formats page in the <a href="https://www.quantconnect.com/docs/v2/writing-algorithms/asset-classes/key-concepts">Asset Classes</a> chapter.</p><p>The <code>Slice</code> object gives you the follow ways to access your data:</p>

<ul>
    <li>Indexing the <code>Slice</code>, which returns a dynamic object of your type.
    </li>
    <div class="section-example-container">
        <pre class="python"># Example slice["IBM"] and slice[self.symbol]</pre>
        <pre class="csharp">// Example slice["IBM"] and slice[self.symbol]</pre>
    </div>

    <li>
        Indexing the static properties, which returns the type you specify.
    </li>
    <div class="section-example-container">
        <pre class="python"># Example slice.Bars[] and slice.QuoteBars[]</pre>
        <pre class="csharp">// Example slice.Bars[] and slice.QuoteBars[]</pre>
    </div>

    <li class="csharp">
        Calling the <code>Get&lt;T&gt;()</code> helper method.
    </li>
    <div class="csharp section-example-container">
        <pre class="csharp">// Example </pre>
    </div>
</ul>

<p class="csharp">Strongly typed access gives you compile-time safety, but dynamic type access can sometimes simplify coding. We recommend static types since they are easier to debug.</p>


<p>You should check if the <code>Slice</code> contains the data you're looking for before you index it. If there is little trading, or you are in the same time loop as when you added the security, it may not have any data. The <code>ContainsKey</code> method returns a boolean that represents if the <code>Slice</code> contains the data you seek. Even if you enabled fill-forward for a security subscription, you should check if the data exists in the dictionary before you try to index it. Note: if the <code>Slice</code> object doesn't contain any market data but it contains auxiliary data, the <code>slice.ContainsKey(symbol)</code> method can return true while <code>slice[symbol]</code> returns <code class="python">None</code><code class="csharp">null</code>.</p>

<div class="section-example-container">
    <pre class="python"># Example ContainsKey</pre>
    <pre class="csharp">// Example ContainsKey</pre>
</div>

<p>To access the current slice outside of the <code>OnData</code> method, use the <code>CurrentSlice</code> property of your algorithm.</p>

<div class="section-example-container">
    <pre class="python">slice = self.CurrentSlice</pre>
    <pre class="csharp">var slice = CurrentSlice;</pre>
</div>
