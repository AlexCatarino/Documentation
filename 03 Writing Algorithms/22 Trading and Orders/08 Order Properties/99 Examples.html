<p>The following examples demonstrate some common practices for utilizing order properties.</p>

<h4>Example 1: Extended Market Hour Orders</h4>
<p>The following algorithm trades SPY pre-market open information. If the overnight price rised, we long SPY, else we short it. We exit the positions at 9:45am to capitalize the price volatility introduced from the pre-market information. To trade in the extended market hours without stale fills, we need to set the respective order properties.</p>
<div class="section-example-container">
    <pre class="csharp">public class OrderPropertiesAlgorithm : QCAlgorithm
{
    private Symbol _spy;
    private decimal _lastPrice = 0m;

    public override void Initialize()
    {
        SetStartDate(2022, 1, 1);
        SetEndDate(2022, 2, 1);
        
        // Request extended market hour SPY data for trading.
        _spy = AddEquity("SPY", extendedMarketHours: true).Symbol;

        // Set a schedule event to trade 2 hours pre-open based on the return direction.
        Schedule.On(
            DateRules.EveryDay(_spy),
            TimeRules.BeforeMarketOpen(_spy, 120),
            OpenPosition
        );
        // Set a schedule event to exit positions at 9:45am.
        Schedule.On(
            DateRules.EveryDay(_spy),
            TimeRules.AfterMarketOpen(_spy, 15),
            ExitPosition
        );
        // Set a schedule event to cache the previous day close price for trade signal generation the next day.
        Schedule.On(
            DateRules.EveryDay(_spy),
            TimeRules.BeforeMarketClose(_spy),
            GetLastPrice
        );
    }

    private void OpenPosition()
    {
        if (_lastPrice &gt; 0m)
        {
            var currentPrice = Securities[_spy].Price;

            // Set up order properties to trade in pre-market open hours. The order will only valid for 3 minutes to avoid stale fills.
            var orderProperties = new InteractiveBrokersOrderProperties
            {
                TimeInForce = TimeInForce.GoodTilDate(Time.AddMinutes(3)),
                OutsideRegularTradingHours = true
            };

            // Buy if the overnight direction is upward, indicating positive market sentiment.
            // Note that pre-market orders do not accept market order.
            if (currentPrice &gt; _lastPrice)
            {
                LimitOrder(_spy, 10, currentPrice, orderProperties: orderProperties);
            }
            // Sell if the overnight direction is downward, indicating negative market sentiment.
            else
            {
                LimitOrder(_spy, -10, currentPrice, orderProperties: orderProperties);
            }
        }
    }

    private void ExitPosition()
    {
        // Liquidate to capitalize the price fluctuation brought by pre-market information.
        Liquidate();
    }

    private void GetLastPrice()
    {
        _lastPrice = Securities[_spy].Price;
    }
}</pre>
    <pre class="python">class OrderPropertiesAlgorithm(QCAlgorithm):
    last_price = None

    def initialize(self) -&gt; None:
        self.set_start_date(2022, 1, 1)
        self.set_end_date(2022, 2, 1)

        # Request extended market hour SPY data for trading.
        self.spy = self.add_equity("SPY", extended_market_hours=True).symbol

        # Set a schedule event to trade 2 hours pre-open based on the return direction.
        self.schedule.on(
            self.date_rules.every_day(self.spy),
            self.time_rules.before_market_open(self.spy, 120),
            self.open_position
        )
        # Set a schedule event to exit positions at 9:45am.
        self.schedule.on(
            self.date_rules.every_day(self.spy),
            self.time_rules.after_market_open(self.spy, 15),
            self.exit_positions
        )
        # Set a schedule event to cache the previous day close price for trade signal generation the next day.
        self.schedule.on(
            self.date_rules.every_day(self.spy),
            self.time_rules.before_market_close(self.spy),
            self.get_last_price
        )

        self.set_warm_up(timedelta(1))
    
    def open_position(self) -&gt; None:
        if self.last_price:
            current_price = self.securities[self.spy].price

            # Set up order properties to trade in pre-market open hours. The order will only valid for 3 minutes to avoid stale fills.
            order_properties = OrderProperties()
            order_properties.time_in_force = TimeInForce.good_til_date(self.time + timedelta(minutes=3))
            order_properties.outside_regular_trading_hours = True

            # Buy if the overnight direction is upward, indicating positive market sentiment.
            # Note that pre-market orders do not accept market order.
            if current_price &gt; self.last_price:
                self.limit_order(self.spy, 10, current_price, order_properties=order_properties)
            # Sell if the overnight direction is downward, indicating negative market sentiment.
            else:
                self.limit_order(self.spy, -10, current_price, order_properties=order_properties)

    def exit_positions(self) -&gt; None:
        # Liquidate to capitalize the price fluctuation brought by pre-market information.
        self.liquidate()

    def get_last_price(self) -&gt; None:
        self.last_price = self.securities[self.spy].price</pre>
</div>

<h4>Example 2: Financial Adviser</h4>
<p>The following algorithm equally holds the top 10 liquid stocks, updating weekly. Nonethless, this algorithm demonstrates using a financial adviser to control its subset of clients.</p>
<div class="section-example-container">
    <pre class="csharp">public class OrderPropertiesAlgorithm : QCAlgorithm
{
    private Universe _universe;

    public override void Initialize()
    {
        SetStartDate(2023, 1, 1);
        SetEndDate(2023, 8, 1);

        // Set order properties to invest a selected FA group. 
        DefaultOrderProperties = new InteractiveBrokersOrderProperties
        {
            FaGroup = "TestGroupEQ",        // FA group
            FaMethod = "NetLiq",            // Allocation by net liquidation
            Account = "FA123456"            // FA account
        };

        // Update the universe weekly to allow time to capitalize the hype.
        UniverseSettings.Schedule.On(DateRules.WeekStart());
        // Filter for the 10 most popular stocks to invest the hype.
        _universe = AddUniverse(Universe.DollarVolume.Top(10));

        // Set a schedule event to rebalance weekly.
        Schedule.On(
            DateRules.WeekStart(),
            TimeRules.At(9, 31),
            Rebalance
        );
    }

    private void Rebalance()
    {
        // Evenly invest in the universe members to equally dissipate the capital risk.
        var count = _universe.Members.Count;
        var targets = _universe.Members.Select(x =&gt; new PortfolioTarget(x.Key, 1m / count)).ToList();
        // We can use `liquidateExistingHoldings` arguments to liquidate the ones not in the universe anymore.
        SetHoldings(targets, liquidateExistingHoldings: true);
    }
}</pre>
    <pre class="python">class OrderPropertiesAlgorithm(QCAlgorithm):
    def initialize(self) -&gt; None:
        self.set_start_date(2023, 1, 1)
        self.set_end_date(2023, 8, 1)

        # Set order properties to invest a selected FA group.
        self.default_order_properties = InteractiveBrokersOrderProperties()
        self.default_order_properties.fa_group = "TestGroupEQ"          # FA group
        self.default_order_properties.fa_method = "EqualQuantity"       # Allocation by net liquidation
        self.default_order_properties.account = "DU123456"              # FA account
        
        # Update the universe weekly to allow time to capitalize the hype.
        self.universe_settings.schedule.on(self.date_rules.week_start())
        # Filter for the 10 most popular stocks to invest the hype.
        self._universe = self.add_universe(self.universe.dollar_volume.top(10))

        # Set a schedule event to rebalance weekly.
        self.schedule.on(
            self.date_rules.week_start(),
            self.time_rules.at(9, 31),
            self.rebalance
        )

    def rebalance(self) -&gt; None:
        # Evenly invest in the universe members to equally dissipate the capital risk.
        count = len(self._universe.members)
        targets = [PortfolioTarget(x.key, 1 / count) for x in self._universe.members]
        # We can use `liquidate_existing_holdings` arguments to liquidate the ones not in the universe anymore.
        self.set_holdings(targets, liquidate_existing_holdings=True)</pre>
</div>