<p>
 The following examples demonstrate common practices for updating indicators using consolidators.
</p>
<h4>
 Example 1: Hammer Pattern With 5-Minute Consolidator
</h4>
<p>
 The following algorithm trades Hammer and Inverted Hammer candlestick patterns. The candles are constructed with five-minute SPY trade bars consolidated by a five-minute
 <code>
  TradeBarConsolidator
 </code>
 , while automatically updating with the
 <code class="csharp">
  RegisterIndicator
 </code>
 <code class="python">
  register_indicator
 </code>
 method. Both patterns are bullish, so we buy SPY if the pattern is signaled.
</p>
<div class="section-example-container testable">
 <pre class="csharp">using QuantConnect.Indicators.CandlestickPatterns;
public class ConsolidatorUpdatingIndicatorsAlgorithm : QCAlgorithm
{
    private Symbol _spy;
    private Hammer _hammer = new();
    private InvertedHammer _invertedHammer = new();

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        
        // Request SPY data for signal generation and trading.
        _spy = AddEquity("SPY", Resolution.Minute).Symbol;

        // The candlestick patterns are based on a 5-minute consolidated trade bar.
        var consolidator = new TradeBarConsolidator(TimeSpan.FromMinutes(5));
        // Subscribe to update the indicators with the 5-minute consolidator automatically.
        RegisterIndicator(_spy, _hammer, consolidator);
        RegisterIndicator(_spy, _invertedHammer, consolidator);
        // Add event handler on candlestick indicators updated to trade the pattern.
        _hammer.Updated += OnUpdated;
        _invertedHammer.Updated += OnUpdated;

        SetWarmUp(1);
    }

    private void OnUpdated(object sender, IndicatorDataPoint point)
    {
        // Both the hammer and inverted Ham patterns indicate bullish movement, so we buy SPY.
        if (point.Value == 1 &amp;&amp; !Portfolio[_spy].IsLong)
        {
            SetHoldings(_spy, 0.5m);
        }
    }

    public override void OnOrderEvent(OrderEvent orderEvent)
    {
        if (orderEvent.Status == OrderStatus.Filled)
        {
            if (orderEvent.Ticket.OrderType == OrderType.Market)
            {
                // Stop loss order at 1%.
                var stopPrice = orderEvent.FillQuantity &gt; 0m ? orderEvent.FillPrice * 0.99m : orderEvent.FillPrice * 1.01m;
                StopMarketOrder(_spy, -Portfolio[_spy].Quantity, stopPrice);
                // Take profit order at 2%.
                var takeProfitPrice = orderEvent.FillQuantity &gt; 0m ? orderEvent.FillPrice * 1.02m : orderEvent.FillPrice * 0.98m;
                LimitOrder(_spy, -Portfolio[_spy].Quantity, takeProfitPrice);
            }
            else if (orderEvent.Ticket.OrderType == OrderType.StopMarket || orderEvent.Ticket.OrderType == OrderType.Limit)
            {
                // Cancel any open order if stop loss or take profit order filled.
                Transactions.CancelOpenOrders();
            }
        }
    }
}</pre>
 <script class="csharp-result" type="text">
  {
    "Total Orders": "39",
    "Average Win": "1.12%",
    "Average Loss": "-0.52%",
    "Compounding Annual Return": "6.107%",
    "Drawdown": "2.500%",
    "Expectancy": "0.323",
    "Start Equity": "100000",
    "End Equity": "101996.20",
    "Net Profit": "1.996%",
    "Sharpe Ratio": "-0.255",
    "Sortino Ratio": "-0.331",
    "Probabilistic Sharpe Ratio": "47.495%",
    "Loss Rate": "58%",
    "Win Rate": "42%",
    "Profit-Loss Ratio": "2.18",
    "Alpha": "-0.032",
    "Beta": "0.404",
    "Annual Standard Deviation": "0.046",
    "Annual Variance": "0.002",
    "Information Ratio": "-0.947",
    "Tracking Error": "0.066",
    "Treynor Ratio": "-0.029",
    "Total Fees": "$25.00",
    "Estimated Strategy Capacity": "$46000000.00",
    "Lowest Capacity Asset": "SPY R735QTJ8XC9X",
    "Portfolio Turnover": "10.20%",
    "Drawdown Recovery": "20",
    "OrderListHash": "51cf33d3c026a81b56e7df1d5de7aeed"
}
 </script>
 <pre class="python">from QuantConnect.Indicators.CandlestickPatterns import *
class ConsolidatorUpdatingIndicatorsAlgorithm(QCAlgorithm):
    hammer = Hammer()
    inverted_hammer = InvertedHammer()

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        
        # Request SPY data for signal generation and trading.
        self.spy = self.add_equity("SPY", Resolution.MINUTE).symbol

        # The candlestick patterns are based on a 5-minute consolidated trade bar.
        consolidator = TradeBarConsolidator(timedelta(minutes=5))
        # Subscribe for automatically updating the indicators with the 5-minute consolidator.
        self.register_indicator(self.spy, self.hammer, consolidator)
        self.register_indicator(self.spy, self.inverted_hammer, consolidator)
        # Add an event handler on candlestick indicators that are updated to trade the pattern.
        self.hammer.updated += self.on_updated
        self.inverted_hammer.updated += self.on_updated

        self.set_warm_up(1)

    def on_updated(self, sender: object, point: IndicatorDataPoint) -&gt; None:
        # Both the hammer and inverted hammer patterns indicate bullish movement, so we buy SPY.
        if point.value == 1 and not self.portfolio[self.spy].is_long:
            self.set_holdings(self.spy, 0.5)

    def on_order_event(self, order_event: OrderEvent) -&gt; None:
        if order_event.status == OrderStatus.FILLED:
            if order_event.ticket.order_type == OrderType.MARKET:
                # Stop loss order at 1%.
                stop_price = order_event.fill_price * (0.99 if order_event.fill_quantity &gt; 0 else 1.01)
                self.stop_market_order(self.spy, -self.portfolio[self.spy].quantity, stop_price)
                # Take profit order at 2%.
                take_profit_price = order_event.fill_price * (1.02 if order_event.fill_quantity &gt; 0 else 0.98)
                self.limit_order(self.spy, -self.portfolio[self.spy].quantity, take_profit_price)
            elif order_event.ticket.order_type == OrderType.STOP_MARKET or order_event.ticket.order_type == OrderType.LIMIT:
                # Cancel any open order if stop loss or take profit order filled.
                self.transactions.cancel_open_orders()</pre>
 <script class="python-result" type="text">
  {
    "Total Orders": "39",
    "Average Win": "1.12%",
    "Average Loss": "-0.52%",
    "Compounding Annual Return": "6.107%",
    "Drawdown": "2.500%",
    "Expectancy": "0.323",
    "Start Equity": "100000",
    "End Equity": "101996.20",
    "Net Profit": "1.996%",
    "Sharpe Ratio": "-0.255",
    "Sortino Ratio": "-0.331",
    "Probabilistic Sharpe Ratio": "47.495%",
    "Loss Rate": "58%",
    "Win Rate": "42%",
    "Profit-Loss Ratio": "2.18",
    "Alpha": "-0.032",
    "Beta": "0.404",
    "Annual Standard Deviation": "0.046",
    "Annual Variance": "0.002",
    "Information Ratio": "-0.947",
    "Tracking Error": "0.066",
    "Treynor Ratio": "-0.029",
    "Total Fees": "$25.00",
    "Estimated Strategy Capacity": "$46000000.00",
    "Lowest Capacity Asset": "SPY R735QTJ8XC9X",
    "Portfolio Turnover": "10.20%",
    "Drawdown Recovery": "20",
    "OrderListHash": "51cf33d3c026a81b56e7df1d5de7aeed"
}
 </script>
</div>
