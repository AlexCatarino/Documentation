<p>The following examples are typical calendar functions you may want.<br></p>

<p>The function should receive a <code class="python">datetime</code><code class="csharp">DateTime</code> object that's based in the <a href="/docs/v2/writing-algorithms/key-concepts/time-modeling/time-zones#04-Algorithm-Time-Zone">algorithm time zone</a> and should return a <code>CalendarInfo</code> object, which contains the start time of the bar in the data time zone and the duration of the consolidation period. This function is evaluated when the duration of the consolidation period has passed and at the following time step.</p><p>

</p><p>The preceding sections of this page provide a typical calendar function that consolidates data weekly, starting at 5:00 PM. If you consolidate US Equity and Crypto data, the event handler triggers at different times since the data time zone of US Equity is America/New York and Crypto is UTC.</p>

<h4>Example 1: Futures Indicator</h4>
<p>Future market trades from 6pm EST to 5pm EST next day, so a calendar consolidator on that time is suitable for updating daily indicator. The following example uses the custmo time consolidated daily bar to update an <a href="/docs/v2/writing-algorithms/indicators/supported-indicators/average-true-range">Average True Range</a> indicator for dynamically updating the take profit and stop loss price on ES future for scalp-trading it.</p>

<div class="section-example-container">
<pre class="csharp">public class CalendarConsolidatorExampleAlgorithm : QCAlgorithm
{
    private Future _es;
    private decimal _takeProfitPrice;
    private decimal _stopLossPrice;
    // Create ATR indicator for take profit and stop loss price.
    private AverageTrueRange _atr = new(10);
    // Day counter to avoid overtrading.
    private int _day = -1;

    public override void Initialize()
    {
        // Request continuous ES Future data for trading and smoothen series for fair indicator feed.
        _es = AddFuture(
            Futures.Indices.SP500EMini,
            Resolution.Minute,
            extendedMarketHours: true,
            dataNormalizationMode: DataNormalizationMode.BackwardsRatio,
            dataMappingMode: DataMappingMode.OpenInterest,
            contractDepthOffset: 0
        );
        // Create a calendar consolidator for ES Future daily bar, since market starts at 6pm EST to 5pm EST next day.
        var consolidator = new TradeBarConsolidator(FutureTradingHour);
        consolidator.DataConsolidated += OnConsolidated;
        // Warm up the ATR indicator using the data consolidated handler by updating the consolidator.
        var history = History&lt;TradeBar&gt;(_es.Symbol, 14500, Resolution.Minute);
        foreach (var bar in history)
        {
            consolidator.Update(bar);
        }
        // Subscribe the consolidator with ES data feed to update it automatically for updating stop price.
        SubscriptionManager.AddConsolidator(_es.Symbol, consolidator);
    }

    private CalendarInfo FutureTradingHour(DateTime datetime)
    {
        // ES market starts at 6pm EST.
        var start = datetime.Date
            .AddHours(datetime.Hour &lt; 18 ? -6 : 18);
        // Ends at 5pm EST next day, which is 23 hours later.
        return new CalendarInfo(start, TimeSpan.FromHours(23));
    }

    private void OnConsolidated(object sender, TradeBar bar)
    {
        // Update the ATR indicator since we want the daily ATR to set the stop price.
        _atr.Update(bar);
        // Update the daily take profit and stop price using the previous close price and the updated ATR.
        _takeProfitPrice = bar.Close + _atr * 2m;
        _stopLossPrice = bar.Close - _atr * 2m;
    }

    public override void OnData(Slice slice)
    {
        // Change in mapped contract will require switching contract.
        if (slice.SymbolChangedEvents.TryGetValue(_es.Symbol, out var changedEvent))
        {
            var oldSymbol = changedEvent.OldSymbol;
            var newSymbol = AddFutureContract(changedEvent.NewSymbol).Symbol;
            var quantity = Portfolio[oldSymbol].Quantity;
            // Rolling over: to liquidate any position of the old mapped contract and switch to the newly mapped contract.
            Liquidate(oldSymbol);
            if (quantity != 0)
            {
                MarketOrder(newSymbol, quantity);
            }

            return;
        }

        // Enter position on a new day if not hold.
        if (!Portfolio.Invested &amp;&amp; _day != slice.Time.Day)
        {
            MarketOrder(_es.Mapped, 1);
        }
        else if (Portfolio.Invested &amp;&amp; slice.Bars.TryGetValue(_es.Symbol, out var bar))
        {
            // Check if the current price is above profit taker or below stop loss to exit the position.
            if (bar.Close &gt; _takeProfitPrice || bar.Close &lt; _stopLossPrice)
            {
                Liquidate();
            }
        }

        _day = slice.Time.Day;
    }
}</pre>
<pre class="python">class CalendarConsolidatorExampleAlgorithm(QCAlgorithm):
    
    def initialize(self) -&gt; None:
        # Create ATR indicator for take profit and stop loss price.
        self._atr = AverageTrueRange(10)
        # Day counter to avoid overtrading.
        self._day = -1

        # Request continuous ES Future data for trading and smoothen series for fair indicator feed.
        self.es = self.add_future(
            Futures.Indices.SP_500_E_MINI,
            Resolution.MINUTE,
            extended_market_hours=True,
            data_normalization_mode=DataNormalizationMode.BACKWARDS_RATIO,
            data_mapping_mode=DataMappingMode.OPEN_INTEREST,
            contract_depth_offset=0
        )
        # Create a calendar consolidator for ES Future daily bar, since market starts at 6pm EST to 5pm EST next day.
        consolidator = TradeBarConsolidator(self.future_trading_hour)
        consolidator.data_consolidated += self.on_consolidated
        # Warm up the ATR indicator using the data consolidated handler by updating the consolidator.
        history = self.history[TradeBar](self.es.symbol, 14500, Resolution.MINUTE)
        for bar in history:
            consolidator.update(bar)
        # Subscribe the consolidator with ES data feed to update it automatically for updating stop price.
        self.subscription_manager.add_consolidator(self.es.symbol, consolidator)
    
    def future_trading_hour(self, dt: datetime) -&gt; CalendarInfo:
        # ES market starts at 6pm EST.
        start = dt.replace(hour=0, minute=0, second=0, microsecond=0)
        if dt.hour &lt; 18:
            start -= timedelta(6)
        else:
            start += timedelta(18)
        # Ends at 5pm EST next day, which is 23 hours later.
        return CalendarInfo(start, timedelta(hours=23))

    def on_consolidated(self, sender: object, bar: TradeBar) -&gt; None:
        # Update the ATR indicator since we want the daily ATR to set the stop price.
        self._atr.update(bar)
        # Update the daily take profit and stop price using the previous close price and the updated ATR.
        self.take_profit_price = bar.close + self._atr.current.value * 2
        self.stop_loss_price = bar.close - self._atr.current.value * 2

    def on_data(self, slice: Slice) -&gt; None:
        # Change in mapped contract will require switching contract.
        changed_event = slice.symbol_changed_events.get(self.es.symbol)
        if changed_event:
            old_symbol = changed_event.old_symbol
            new_symbol = self.add_future_contract(changed_event.new_symbol).symbol
            quantity = self.portfolio[old_symbol].quantity
            # Rolling over: to liquidate any position of the old mapped contract and switch to the newly mapped contract.
            self.liquidate(old_symbol)
            if quantity != 0:
                self.market_order(new_symbol, quantity)
            
            return

        # Enter position on a new day if not hold.
        if not self.portfolio.invested and self._day != slice.time.day:
            self.market_order(self.es.mapped, 1)
        elif self.portfolio.invested and self.es.symbol in slice.bars:
            current_price = slice.bars[self.es.symbol].close
            # Check if the current price is above profit taker or below stop loss to exit the position.
            if (current_price &gt; self.take_profit_price or current_price &lt; self.stop_loss_price):
                self.liquidate()

        self._day = slice.time.day</pre>
</div>
<p>To consolidate data into another period, change the <code>period</code> variable. For example, to consolidate into 5-minute bars, replace <code class="python">timedelta(hours=23)</code><code class="csharp">TimeSpan.FromHours(23)</code> with <code class="python">timedelta(minutes=5)</code><code class="csharp">TimeSpan.FromMinutes(5)</code>.</p>

<h4>Example 2: Consolidate data in daily <code>QuoteBar</code> objects that start at 5 PM:</h4>
<p>This is a typical Forex case because the Forex market opens on Sunday at 5 PM ET. We try to make use of this daily bar for an EMA cross strategy.</p>

<div class="section-example-container">
    <pre class="csharp">public class CalendarConsolidatorExampleAlgorithm : QCAlgorithm
{
    private Symbol _usdjpy;
    private ExponentialMovingAverage _ema = new(20);

    public override void Initialize()
    {
        // Request USDJPY, as one of the most traded and trend-oriented forex, for trading.
        _usdjpy = AddForex("USDJPY").Symbol;
        // Create a calendar consolidator for USDJPY daily bar, since forex trades from 5pm EST to 5pm EST next day.
        // Note that forex only have quote bar data.
        var consolidator = new QuoteBarConsolidator(CustomDailyForex);
        // Update the EMA indicator, as we use 20-day EMA to determine the trade.
        RegisterIndicator(_usdjpy, _ema, consolidator);
        // Warm up the EMA indicator using the data consolidated handler by updating the consolidator.
        var history = History&lt;QuoteBar&gt;(_usdjpy, 29000, Resolution.Minute);
        foreach (var bar in history)
        {
            consolidator.Update(bar);
        }
        // Subscribe the consolidator with USDJPY data feed to update it automatically.
        SubscriptionManager.AddConsolidator(_usdjpy, consolidator);
    }

    public CalendarInfo CustomDailyForex(DateTime datetime)
    {
        // Forex market opens at 5pm EST.
        var start = datetime.Date
            .AddHours(datetime.Hour &lt; 17 ? -7 : 17);
        return new CalendarInfo(start, TimeSpan.FromDays(1));
    }

    public override void OnData(Slice slice)
    {
        // Only trade based on updated price and EMA data.
        if (!_ema.IsReady || !slice.QuoteBars.TryGetValue(_usdjpy, out var quote))
        {
            return;
        }

        // Long if the price above EMA, suggesting the trend is uprising and we follow the trend.
        if (quote.Close &gt; _ema)
        {
            // Trade with 5x leverage for higher return.
            SetHoldings(_usdjpy, 1);
        }
        // Short if the price below EMA, suggesting the trend is downgoing and we follow the trend.
        else
        {
            SetHoldings(_usdjpy, -1);
        }
    }
}</pre>
    <pre class="python">class CalendarConsolidatorExampleAlgorithm(QCAlgorithm):
    
    def initialize(self) -&gt; None:
        # Create ATR indicator for take profit and stop loss price.
        self._ema = ExponentialMovingAverage(10)

        # Request USDJPY, as one of the most traded and trend-oriented forex, for trading.
        self.usdjpy = self.add_forex("USDJPY").symbol
        # Create a calendar consolidator for USDJPY daily bar, since market open at 5pm EST to 5pm EST next day.
        # Note that forex only have quote bar data.
        consolidator = QuoteBarConsolidator(self.custom_daily_forex)
        # Update the EMA indicator, as we use 20-day EMA to determine the trade.
        self.register_indicator(self.usdjpy, self._ema, consolidator)
        # Warm up the EMA indicator using the data consolidated handler by updating the consolidator.
        history = self.history[QuoteBar](self.usdjpy, 29000, Resolution.MINUTE)
        for bar in history:
            consolidator.update(bar)
        # Subscribe the consolidator with USDJPY data feed to update it automatically.
        self.subscription_manager.add_consolidator(self.usdjpy, consolidator)
    
    def custom_daily_forex(self, dt: datetime) -&gt; CalendarInfo:
        # Forex market opens at 5pm EST.
        start = dt.replace(hour=0, minute=0, second=0, microsecond=0)
        if dt.hour &lt; 17:
            start -= timedelta(7)
        else:
            start += timedelta(17)
        # Ends at 5pm EST next day.
        return CalendarInfo(start, timedelta(1))

    def on_data(self, slice: Slice) -&gt; None:
        # Only trade based on updated price and EMA data.
        if not self._ema.is_ready or self.usdjpy not in slice.quote_bars:
            return
        
        price = slice.quote_bars[self.usdjpy].close
        # Long if the price above EMA, suggesting the trend is uprising and we follow the trend.
        if price &gt; self._ema.current.value:
            self.set_holdings(self.usdjpy, 1)
        else:
            self.set_holdings(self.usdjpy, -1)</pre>
</div>

<h4>Example 3: Monthly Candlesticks</h4>
<p>The following algorithm consolidates minute-resolution data into monthly <code>TradeBar</code> objects and then <a href='/docs/v2/writing-algorithms/charting#06-Plot-Candlestick'>plots them as candlesticks</a>.</p>

<div class="section-example-container">
    <pre class="csharp">public class CalendarConsolidatorExampleAlgorithm : QCAlgorithm
{
    public override void Initialize()
    {
        // Add an asset.
        var symbol = AddEquity("SPY").Symbol;
        // Create a consolidator that produces monthly TradeBar objects.
        // This is the stardard way:
        //var consolidator = new TradeBarConsolidator(Calendar.Monthly);
        // However, you can acomplish the same thing with a custom period:
        var consolidator = new TradeBarConsolidator(CustomMonthly);
        // Add a consolidation handler that plots the monthly bars as candlesticks.
        consolidator.DataConsolidated += (_, bar) => Plot(
            "Monthly Candlestick", symbol.Value, bar.Open, bar.High, bar.Low, bar.Close
        );
        // Register the consolidator for automatic updates.
        SubscriptionManager.AddConsolidator(symbol, consolidator);
    }

    public CalendarInfo CustomMonthly(DateTime dt)
    {
        // Set the start time to the beginning of the month.
        var start = dt.AddDays(1 - dt.Day).Date;
        // Set the end time to the beginning of next month.
        var end = start.AddMonths(1);
        return new CalendarInfo(start, (end - start));
    }
}</pre>
    <pre class="python">from dateutil.relativedelta import relativedelta


class CalendarConsolidatorExampleAlgorithm(QCAlgorithm):
    
    def initialize(self) -> None:
        # Add an asset.
        symbol = self.add_equity("SPY").symbol
        # Create a consolidator that produces monthly TradeBar objects.
        # This is the stardard way:
        #consolidator = TradeBarConsolidator(Calendar.MONTHLY)
        # However, you can acomplish the same thing with a custom period:
        consolidator = TradeBarConsolidator(self._custom_monthly)
        # Add a consolidation handler that plots the monthly bars as candlesticks.
        consolidator.data_consolidated += lambda _, bar: self.plot(
            "Monthly Candlestick", symbol.value, bar.open, bar.high, bar.low, bar.close
        )
        # Register the consolidator for automatic updates.
        self.subscription_manager.add_consolidator(symbol, consolidator)
    
    def _custom_monthly(self, dt: datetime) -> CalendarInfo:
        # Set the start time to the beginning of the month.
        start = dt.replace(day=1).date()
        # Set the end time to the beginning of next month.
        end = start + relativedelta(months=1)
        return CalendarInfo(start, end - start)</pre>
</div>

<h4>Other Examples</h4>
<p>For more examples, see the following algorithms:</p>
<div class="example-fieldset"> 
    <div class="example-legend">Demonstration Algorithms</div>
    
    <a class="python example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.Python/DataConsolidationAlgorithm.py" target="_BLANK">
        DataConsolidationAlgorithm.py <span class="badge-python pull-right">Python</span>
    </a>
    
    <a class="csharp example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.CSharp/DataConsolidationAlgorithm.cs" target="_BLANK">
        DataConsolidationAlgorithm.cs <span class="badge-csharp pull-right">C#</span>
    </a>
</div>
