<p>The following examples demonstrate some common practices for calendar consolidators.</p>

<h4>Example 1: Daily Futures Bars</h4>
<p>
    Daily bars from the CME and Yahoo Finance represent the price action from 5 PM Central Time (CT) to 4 PM CT on the following day. 
    In contrast, the regular daily resolution bars on QuantConnect represent the price action from 12 AM Eastern Time (ET) to 12 AM ET the following day. 
    To create daily bars that represent the same period of time as the daily bars from the CME, the following algorithm consolidates minute bars (during regular and extended market hours) into daily bars that span from 5 PM CT to 4 PM CT on the following day.
    The algorithm then uses these consolidated daily bars to place take profit and stop loss orders as a function of the daily <a href="/docs/v2/writing-algorithms/indicators/supported-indicators/average-true-range">Average True Range</a>.
</p>

<div class="section-example-container">
<pre class="csharp">public class CalendarConsolidatorExampleAlgorithm : QCAlgorithm
{
    private Future _future;
    private decimal _takeProfitPrice, _stopLossPrice;
    // Create an ATR indicator to set take profit and stop loss levels.
    private AverageTrueRange _atr = new(10);
    // Create a day tracker to avoid over-trading.
    private int _day = -1;

    public override void Initialize()
    {
        SetStartDate(2021, 1, 1);
        SetEndDate(2022, 1, 1);
        // Add ES Futures data and configure the continuous contract settings 
        // so you can update the ATR with a smooth feed of prices.
        _future = AddFuture(
            Futures.Indices.SP500EMini,
            extendedMarketHours: true,
            dataNormalizationMode: DataNormalizationMode.BackwardsRatio,
            dataMappingMode: DataMappingMode.OpenInterest,
            contractDepthOffset: 0
        );
        // Create a calendar consolidator to generate daily ES Futures bars
        // since market starts at 6pm EST to 5pm EST next day.
        var consolidator = new TradeBarConsolidator(FutureTradingHour);
        consolidator.DataConsolidated += OnConsolidated;
        // Warm up the consolidator and ATR indicator.
        var history = History&lt;TradeBar&gt;(_future.Symbol, 14500, Resolution.Minute);
        foreach (var bar in history)
        {
            consolidator.Update(bar);
        }
        // Subscribe the consolidator for automatic updates with ES data.
        SubscriptionManager.AddConsolidator(_future.Symbol, consolidator);
    }

    private CalendarInfo FutureTradingHour(DateTime datetime)
    {
        // Set the open time of the bar to be 6 PM EST.
        var start = datetime.Date.AddHours(datetime.Hour < 18 ? -6 : 18);
        // Set the close time of the bar to be 5 PM EST the next day, which is 23 hours later.
        return new CalendarInfo(start, TimeSpan.FromHours(23));
    }

    private void OnConsolidated(object sender, TradeBar bar)
    {
        // Update the ATR indicator since we want the daily ATR to set the stop price.
        _atr.Update(bar);
        // Set the daily take profit and stop price levels as a function of the previous 
        // close price and the ATR.
        _takeProfitPrice = bar.Close + _atr * 2m;
        _stopLossPrice = bar.Close - _atr * 2m;
    }

    public override void OnData(Slice slice)
    {
        // Liquidate the current contract in the continuous contract series
        // when it's about to expire.
        if (slice.SymbolChangedEvents.TryGetValue(_future.Symbol, out var changedEvent))
        {
            Liquidate(changedEvent.OldSymbol);
        }

        // If we're not invested, buy the current contract in the continuous contract series.
        if (!Portfolio.Invested && Securities[_future.Mapped].Price != 0 && _day != slice.Time.Day)
        {
            MarketOrder(_future.Mapped, 1);
        }
        // If we're already invested, check if we've hit the TP/SL level.
        else if (Portfolio.Invested && slice.Bars.TryGetValue(_future.Symbol, out var bar))
        {
            // Check if the current price is above profit taker or below stop loss.
            if (bar.Close > _takeProfitPrice || bar.Close < _stopLossPrice)
            {
                // Exit the position.
                Liquidate();
            }
        }
        // Update the daily tracker so we only update our position once per day.
        _day = slice.Time.Day;
    }
}</pre>
<pre class="python">class CalendarConsolidatorExampleAlgorithm(QCAlgorithm):
    
    def initialize(self) -> None:
        self.set_start_date(2021, 1, 1)
        self.set_end_date(2022, 1, 1)
        # Create an ATR indicator to set take profit and stop loss levels.
        self._atr = AverageTrueRange(10)
        # Create a day tracker to avoid overtrading.
        self._day = -1
        # Add ES Futures data and configure the continuous contract settings 
        # so you can update the ATR with a smooth feed of prices.
        self._future = self.add_future(
            Futures.Indices.SP_500_E_MINI,
            extended_market_hours=True,
            data_normalization_mode=DataNormalizationMode.BACKWARDS_RATIO,
            data_mapping_mode=DataMappingMode.OPEN_INTEREST,
            contract_depth_offset=0
        )
        # Create a calendar consolidator to generate daily ES Futures bars
        # since market starts at 6pm EST to 5pm EST next day.
        consolidator = TradeBarConsolidator(self._future_trading_hour)
        consolidator.data_consolidated += self._on_consolidated
        # Warm up the consolidator and ATR indicator.
        history = self.history[TradeBar](self._future.symbol, 14500, Resolution.MINUTE)
        for bar in history:
            consolidator.update(bar)
        # Subscribe the consolidator for automatic updates with ES data.
        self.subscription_manager.add_consolidator(self._future.symbol, consolidator)
    
    def _future_trading_hour(self, dt: datetime) -> CalendarInfo:
        # Set the open time of the bar to be 6 PM EST.
        start = dt.replace(hour=0, minute=0, second=0, microsecond=0)
        if dt.hour < 18:
            start -= timedelta(hours=6)
        else:
            start += timedelta(hours=18)
        # Set the close time of the bar to be 5 PM EST the next day, which is 23 hours later.
        return CalendarInfo(start, timedelta(hours=23))

    def _on_consolidated(self, sender: object, bar: TradeBar) -> None:
        # Update the ATR indicator since we want the daily ATR to set the stop price.
        self._atr.update(bar)
        # Set the daily take profit and stop price levels as a function of the previous 
        # close price and the ATR.
        self._take_profit_price = bar.close + self._atr.current.value * 2
        self._stop_loss_price = bar.close - self._atr.current.value * 2

    def on_data(self, slice: Slice) -> None:
        # Liquidate the current contract in the continuous contract series
        # when it's about to expire.
        changed_event = slice.symbol_changed_events.get(self._future.symbol)
        if changed_event:
            self.liquidate(changed_event.old_symbol)

        # If we're not invested, buy the current contract in the continuous contract series.
        if (not self.portfolio.invested and 
            self.securities[self._future.mapped].price and 
            self._day != slice.time.day):
            self.market_order(self._future.mapped, 1)
        # If we're already invested, check if we've hit the TP/SL level.
        elif self.portfolio.invested and self._future.symbol in slice.bars:
            current_price = slice.bars[self._future.symbol].close
            # Check if the current price is above profit taker or below stop loss.
            if current_price > self._take_profit_price or current_price < self._stop_loss_price:
                # Exit the position.
                self.liquidate()
        
        # Update the daily tracker so we only update our position once per day.
        self._day = slice.time.day</pre>
</div>

<h4>Example 2: Consolidate data in daily <code>QuoteBar</code> objects that start at 5 PM:</h4>
<p>This is a typical Forex case because the Forex market opens on Sunday at 5 PM ET. We try to make use of this daily bar for an EMA cross strategy.</p>

<div class="section-example-container">
    <pre class="csharp">public class CalendarConsolidatorExampleAlgorithm : QCAlgorithm
{
    private Symbol _usdjpy;
    private ExponentialMovingAverage _ema = new(20);

    public override void Initialize()
    {
        // Request USDJPY, as one of the most traded and trend-oriented forex, for trading.
        _usdjpy = AddForex("USDJPY").Symbol;
        // Create a calendar consolidator for USDJPY daily bar, since forex trades from 5pm EST to 5pm EST next day.
        // Note that forex only have quote bar data.
        var consolidator = new QuoteBarConsolidator(CustomDailyForex);
        // Update the EMA indicator, as we use 20-day EMA to determine the trade.
        RegisterIndicator(_usdjpy, _ema, consolidator);
        // Warm up the EMA indicator using the data consolidated handler by updating the consolidator.
        var history = History&lt;QuoteBar&gt;(_usdjpy, 29000, Resolution.Minute);
        foreach (var bar in history)
        {
            consolidator.Update(bar);
        }
        // Subscribe the consolidator with USDJPY data feed to update it automatically.
        SubscriptionManager.AddConsolidator(_usdjpy, consolidator);
    }

    public CalendarInfo CustomDailyForex(DateTime datetime)
    {
        // Forex market opens at 5pm EST.
        var start = datetime.Date
            .AddHours(datetime.Hour &lt; 17 ? -7 : 17);
        return new CalendarInfo(start, TimeSpan.FromDays(1));
    }

    public override void OnData(Slice slice)
    {
        // Only trade based on updated price and EMA data.
        if (!_ema.IsReady || !slice.QuoteBars.TryGetValue(_usdjpy, out var quote))
        {
            return;
        }

        // Long if the price above EMA, suggesting the trend is uprising and we follow the trend.
        if (quote.Close &gt; _ema)
        {
            // Trade with 5x leverage for higher return.
            SetHoldings(_usdjpy, 1);
        }
        // Short if the price below EMA, suggesting the trend is downgoing and we follow the trend.
        else
        {
            SetHoldings(_usdjpy, -1);
        }
    }
}</pre>
    <pre class="python">class CalendarConsolidatorExampleAlgorithm(QCAlgorithm):
    
    def initialize(self) -&gt; None:
        # Create ATR indicator for take profit and stop loss price.
        self._ema = ExponentialMovingAverage(10)

        # Request USDJPY, as one of the most traded and trend-oriented forex, for trading.
        self.usdjpy = self.add_forex("USDJPY").symbol
        # Create a calendar consolidator for USDJPY daily bar, since market open at 5pm EST to 5pm EST next day.
        # Note that forex only have quote bar data.
        consolidator = QuoteBarConsolidator(self.custom_daily_forex)
        # Update the EMA indicator, as we use 20-day EMA to determine the trade.
        self.register_indicator(self.usdjpy, self._ema, consolidator)
        # Warm up the EMA indicator using the data consolidated handler by updating the consolidator.
        history = self.history[QuoteBar](self.usdjpy, 29000, Resolution.MINUTE)
        for bar in history:
            consolidator.update(bar)
        # Subscribe the consolidator with USDJPY data feed to update it automatically.
        self.subscription_manager.add_consolidator(self.usdjpy, consolidator)
    
    def custom_daily_forex(self, dt: datetime) -&gt; CalendarInfo:
        # Forex market opens at 5pm EST.
        start = dt.replace(hour=0, minute=0, second=0, microsecond=0)
        if dt.hour &lt; 17:
            start -= timedelta(hours=7)
        else:
            start += timedelta(hours=17)
        # Ends at 5pm EST next day.
        return CalendarInfo(start, timedelta(1))

    def on_data(self, slice: Slice) -&gt; None:
        # Only trade based on updated price and EMA data.
        if not self._ema.is_ready or self.usdjpy not in slice.quote_bars:
            return
        
        price = slice.quote_bars[self.usdjpy].close
        # Long if the price above EMA, suggesting the trend is uprising and we follow the trend.
        if price &gt; self._ema.current.value:
            self.set_holdings(self.usdjpy, 1)
        else:
            self.set_holdings(self.usdjpy, -1)</pre>
</div>

<h4>Example 3: Monthly Candlesticks</h4>
<p>The following algorithm consolidates minute-resolution data into monthly <code>TradeBar</code> objects and then <a href='/docs/v2/writing-algorithms/charting#06-Plot-Candlestick'>plots them as candlesticks</a>.</p>

<div class="section-example-container">
    <pre class="csharp">public class CalendarConsolidatorExampleAlgorithm : QCAlgorithm
{
    public override void Initialize()
    {
        // Add an asset.
        var symbol = AddEquity("SPY").Symbol;
        // Create a consolidator that produces monthly TradeBar objects.
        // This is the stardard way:
        //var consolidator = new TradeBarConsolidator(Calendar.Monthly);
        // However, you can acomplish the same thing with a custom period:
        var consolidator = new TradeBarConsolidator(CustomMonthly);
        // Add a consolidation handler that plots the monthly bars as candlesticks.
        consolidator.DataConsolidated += (_, bar) => Plot(
            "Monthly Candlestick", symbol.Value, bar.Open, bar.High, bar.Low, bar.Close
        );
        // Register the consolidator for automatic updates.
        SubscriptionManager.AddConsolidator(symbol, consolidator);
    }

    public CalendarInfo CustomMonthly(DateTime dt)
    {
        // Set the start time to the beginning of the month.
        var start = dt.AddDays(1 - dt.Day).Date;
        // Set the end time to the beginning of next month.
        var end = start.AddMonths(1);
        return new CalendarInfo(start, (end - start));
    }
}</pre>
    <pre class="python">from dateutil.relativedelta import relativedelta


class CalendarConsolidatorExampleAlgorithm(QCAlgorithm):
    
    def initialize(self) -> None:
        # Add an asset.
        symbol = self.add_equity("SPY").symbol
        # Create a consolidator that produces monthly TradeBar objects.
        # This is the stardard way:
        #consolidator = TradeBarConsolidator(Calendar.MONTHLY)
        # However, you can acomplish the same thing with a custom period:
        consolidator = TradeBarConsolidator(self._custom_monthly)
        # Add a consolidation handler that plots the monthly bars as candlesticks.
        consolidator.data_consolidated += lambda _, bar: self.plot(
            "Monthly Candlestick", symbol.value, bar.open, bar.high, bar.low, bar.close
        )
        # Register the consolidator for automatic updates.
        self.subscription_manager.add_consolidator(symbol, consolidator)
    
    def _custom_monthly(self, dt: datetime) -> CalendarInfo:
        # Set the start time to the beginning of the month.
        start = dt.replace(day=1).date()
        # Set the end time to the beginning of next month.
        end = start + relativedelta(months=1)
        return CalendarInfo(start, end - start)</pre>
</div>

<h4>Other Examples</h4>
<p>For more examples, see the following algorithms:</p>
<div class="example-fieldset"> 
    <div class="example-legend">Demonstration Algorithms</div>
    
    <a class="python example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.Python/DataConsolidationAlgorithm.py" target="_BLANK">
        DataConsolidationAlgorithm.py <span class="badge-python pull-right">Python</span>
    </a>
    
    <a class="csharp example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.CSharp/DataConsolidationAlgorithm.cs" target="_BLANK">
        DataConsolidationAlgorithm.cs <span class="badge-csharp pull-right">C#</span>
    </a>
</div>
