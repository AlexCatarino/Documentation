<p>
 The following examples demonstrate some common practices for handling Crypto Futures data.
</p>
<h4>
 Example 1: Adjust Holdings on Margin Payments
</h4>
<p>
 Perpetual futures have a mechanism called
 <span class="new-term">
  funding
 </span>
 , where if you're holding a position at certain times (the funding timestamp), you might have to pay or receive funding based on the difference between the perpetual contract price and the spot price.
    This example demonstrates how to adjust your position in Crypto Future based on the funding rate.
    The funding is settled in the quote currency, which is USDT in this case.
    When you receive USDT, the algorithm increases its position size in BTCUSDT.
    When you pay USDT, the algorithm decreases its position size.
</p>
<div class="section-example-container testable">
 <pre class="csharp">public class CryptoFutureAlgorithm : QCAlgorithm
{
    private Symbol _symbol;
    private decimal _lotSize;
    private int _day = -1;

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        // Set brokerage and account type to match your brokerage environment for accurate fee and margin behavior.
        SetBrokerageModel(BrokerageName.Binance, AccountType.Margin);
        // In the Binance brokerage, you can't trade with USD.
        // Set the account currency as USDT and add the starting cash.
        SetAccountCurrency("USDT", 1000000);
        // Subscribe to the BTCUSDT perpetual Future contract.
        var btcusdt = AddCryptoFuture("BTCUSDT");
        _symbol = btcusdt.Symbol;
        // Save the lot size to avoid order errors.
        _lotSize = btcusdt.SymbolProperties.LotSize;
        // Set the starting BTC balance to 10.
        btcusdt.BaseCurrency.SetAmount(10);
    }

    public override void OnData(Slice slice)
    {
        // Only place orders when the market is open since market on open orders aren't supported.
        if (!Portfolio.Invested &amp;&amp; IsMarketOpen(_symbol))
        {
            // Open a long position in the perpetual Crypto Future.
            MarketOrder(_symbol, 10);
        }
        // Only run the following logic once per day.
        if (_day == Time.Day)
        {
            return;
        }
        // Get the current margin interest rate.
        MarginInterestRate interestRate;
        if (!slice.MarginInterestRates.TryGetValue(_symbol, out interestRate))
        {
            return;
        }
        // Calculate the funding payment.
        var holding = Portfolio[_symbol];
        var positionValue = holding.GetQuantityValue(holding.Quantity).Amount;
        var funding = interestRate.InterestRate * positionValue / holding.Price;
        // Increase/decrease the position size based on the funding payment.
        var quantity = -(int)(funding / _lotSize) * _lotSize;
        if (quantity != 0)
        {
            MarketOrder(_symbol, quantity);
            // Plot the portfolio state.
            Plot("CashBook", "USDT", Portfolio.CashBook["USDT"].Amount);
            Plot("CashBook", "BTC", Portfolio.CashBook["BTC"].Amount);
            Plot("Quantity", "BTCUSDT", Portfolio[_symbol].Quantity);
        }
        _day = Time.Day;
    }
}</pre>
 <script class="csharp-result" type="text">
  {
    "Total Orders": "18",
    "Average Win": "0.00%",
    "Average Loss": "0%",
    "Compounding Annual Return": "198.241%",
    "Drawdown": "10.600%",
    "Expectancy": "0",
    "Start Equity": "1585242.10",
    "End Equity": "2284401.94",
    "Net Profit": "44.104%",
    "Sharpe Ratio": "7.298",
    "Sortino Ratio": "14.799",
    "Probabilistic Sharpe Ratio": "97.548%",
    "Loss Rate": "0%",
    "Win Rate": "100%",
    "Profit-Loss Ratio": "0",
    "Alpha": "0.39",
    "Beta": "0.486",
    "Annual Standard Deviation": "0.301",
    "Annual Variance": "0.09",
    "Information Ratio": "-4.89",
    "Tracking Error": "0.311",
    "Treynor Ratio": "4.514",
    "Total Fees": "\u20ae588.28",
    "Estimated Strategy Capacity": "\u20ae22000000.00",
    "Lowest Capacity Asset": "BTCUSDT 18R",
    "Portfolio Turnover": "0.31%",
    "Drawdown Recovery": "20",
    "OrderListHash": "a801f32232a4548dc8d2b43181ee5e7a"
}
 </script>
 <pre class="python">class CryptoFutureAlgorithm(QCAlgorithm):

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        # Set brokerage and account type to match your brokerage environment for accurate fee and margin behavior.
        self.set_brokerage_model(BrokerageName.BINANCE, AccountType.MARGIN)
        # In the Binance brokerage, you can't trade with USD.
        # Set the account currency as USDT and add the starting cash.
        self.set_account_currency("USDT", 1000000)
        # Subscribe to the BTCUSDT perpetual Future contract.
        btcusdt = self.add_crypto_future("BTCUSDT")
        self._symbol = btcusdt.symbol
        # Save the lot size to avoid order errors.
        self._lot_size = btcusdt.symbol_properties.lot_size
        # Set the starting BTC balance to 10.
        btcusdt.base_currency.set_amount(10)
        # Create a member to track the current day.
        self._day = -1
    
    def on_data(self, slice: Slice) -&gt; None:
        # Only place orders when the market is open since market on open orders aren't supported.
        if not self.portfolio.invested and self.is_market_open(self._symbol):
            # Open a long position in the perpetual Crypto Future.
            self.market_order(self._symbol, 10)
        # Only run the following logic once per day.
        if self._day == self.time.day:
            return
        # Get the current margin interest rate.
        interest_rate = slice.margin_interest_rates.get(self._symbol)
        if not interest_rate:
            return
        # Calculate the funding payment.
        holding = self.portfolio[self._symbol]
        position_value = holding.get_quantity_value(holding.quantity).amount
        interest_rate = slice.margin_interest_rates[self._symbol].interest_rate
        funding = interest_rate * position_value / holding.security.price
        # Increase/decrease the position size based on the funding payment.
        quantity = -funding // self._lot_size * self._lot_size
        if quantity:
            self.market_order(self._symbol, quantity)
            # Plot the portfolio state.
            self.plot("CashBook", "USDT", self.portfolio.cash_book['USDT'].amount)
            self.plot("CashBook", "BTC", self.portfolio.cash_book['BTC'].amount)
            self.plot("Quantity", "BTCUSDT", self.portfolio[self._symbol].quantity)
        self._day = self.time.day</pre>
 <script class="python-result" type="text">
  {
    "Total Orders": "111",
    "Average Win": "0.00%",
    "Average Loss": "0.00%",
    "Compounding Annual Return": "197.636%",
    "Drawdown": "10.500%",
    "Expectancy": "14.144",
    "Start Equity": "1585242.10",
    "End Equity": "2282849.73",
    "Net Profit": "44.006%",
    "Sharpe Ratio": "7.291",
    "Sortino Ratio": "14.773",
    "Probabilistic Sharpe Ratio": "97.544%",
    "Loss Rate": "4%",
    "Win Rate": "96%",
    "Profit-Loss Ratio": "14.72",
    "Alpha": "0.383",
    "Beta": "0.486",
    "Annual Standard Deviation": "0.3",
    "Annual Variance": "0.09",
    "Information Ratio": "-4.923",
    "Tracking Error": "0.31",
    "Treynor Ratio": "4.5",
    "Total Fees": "\u20ae596.96",
    "Estimated Strategy Capacity": "\u20ae4100000.00",
    "Lowest Capacity Asset": "BTCUSDT 18R",
    "Portfolio Turnover": "0.31%",
    "Drawdown Recovery": "20",
    "OrderListHash": "56c0c2bb614813ea04e6d2a8082003b8"
}
 </script>
</div>
<h4>
 Example 2: Future-Spot Arbitrage
</h4>
<p>
    Long-short arbitrage involves simultaneously trading BTCUSDT in the spot market and BTCUSDT Futures with the same size but in the opposite direction. 
    The following algorithm monitors the spread between these markets.
    If the spot price exceeds the Future price by a threshold, it shorts the spot market and buys the Future contract (and vice vera for the other way around), assuming their discrepancies will be wiped out within a short period due to market efficiency. 
    It closes the positions after the spread inverts.
</p>
<div class="section-example-container testable">
 <pre class="csharp">public class CryptoFutureArbitrageAlgorithm : QCAlgorithm
{
    private Crypto _spot;
    private CryptoFuture _future;
    private decimal _multiplier;
    private decimal _threshold = 1.005m;  // 0.5%
    
    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        // Set brokerage and account type to match your brokerage 
        // environment for accurate fee and margin behavior.
        SetBrokerageModel(BrokerageName.Binance, AccountType.Margin);
        // In the Binance brokerage, you can't trade with USD.
        // Set the account currency to USDT and add the starting cash.
        SetAccountCurrency("USDT", 50000000);
        // Add the BTCUSDT spot and Futures markets.
        _spot = AddCrypto("BTCUSDT", fillForward: false, market: Market.Binance);
        _future = AddCryptoFuture("BTCUSDT", fillForward: false, market: Market.Binance);
        _multiplier = _future.SymbolProperties.ContractMultiplier;
    }
    
    public override void OnData(Slice slice)
    {
        // Wait for there to be a TradeBar for each asset, so we know
        // the prices are up-to-date.
        foreach (var security in new List&lt;Security&gt;() {_spot, _future})
            if (!slice.Bars.ContainsKey(security.Symbol)) return;
        var spot = _spot.Price;
        var future = _future.Price;
        // Buy low sell high: If one's price is above another by the 
        // set threshold, sell it and buy the other security. The 
        // threshold ensures there is enough profit potential to overcome
        // the fees and slippage. Make sure to equalize the actual order
        // size with the contract multiplier.
        if (spot >= future * _threshold)
        {
            Enter(-1, 1);
        }
        else if (future >= spot * _threshold)
        {
            Enter(1, -1);
        }
        // When the mispricing converges, close both positions to earn 
        // the spread.
        else if (_spot.Invested)
        {
            // Scan for an exit.
            if ((_spot.Holdings.IsShort && spot < future) || 
                (_spot.Holdings.IsLong && spot > future))
            {
                // Liquidate the spot position.
                var quantity = Math.Min(_spot.Holdings.Quantity, _spot.BaseCurrency.Amount);
                if (quantity < 0m)
                {
                    quantity /= (1 - 0.001m);  // To cover the taker fees.
                }
                var lotSize = _spot.SymbolProperties.LotSize;
                MarketOrder(_spot.Symbol, -Math.Round(quantity / lotSize) * lotSize, tag: "Liquidate Spot");
                // Liquidate the Future position.
                Liquidate(_future.Symbol, tag: "Liquidate Future");
            }
        }
    }

    private void Enter(int spotSign, int futureSign)
    {
        var quantity = CalculateOrderQuantity(_future.Symbol, 0.5d);
        if (quantity == 0) return;
        // Enter the spot position.
        MarketOrder(_spot.Symbol, spotSign * quantity * _multiplier, tag: "Spot");
        // Enter the Future position.
        MarketOrder(_future.Symbol, futureSign * quantity, tag: "Future");
    }
}</pre>
 <script class="csharp-result" type="text">
  {
    "Total Orders": "0",
    "Average Win": "0%",
    "Average Loss": "0%",
    "Compounding Annual Return": "0%",
    "Drawdown": "0%",
    "Expectancy": "0",
    "Start Equity": "50000000.00",
    "End Equity": "50000000",
    "Net Profit": "0%",
    "Sharpe Ratio": "0",
    "Sortino Ratio": "0",
    "Probabilistic Sharpe Ratio": "0%",
    "Loss Rate": "0%",
    "Win Rate": "0%",
    "Profit-Loss Ratio": "0",
    "Alpha": "0",
    "Beta": "0",
    "Annual Standard Deviation": "0",
    "Annual Variance": "0",
    "Information Ratio": "-8.094",
    "Tracking Error": "0.465",
    "Treynor Ratio": "0",
    "Total Fees": "\u20ae0.00",
    "Estimated Strategy Capacity": "\u20ae0",
    "Lowest Capacity Asset": "",
    "Portfolio Turnover": "0%",
    "Drawdown Recovery": "0",
    "OrderListHash": ""
}
 </script>
 <pre class="python">class CryptoFutureArbitrageAlgorithm(QCAlgorithm):
    
    def initialize(self) -> None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        # Set brokerage and account type to match your brokerage 
        # environment for accurate fee and margin behavior.
        self.set_brokerage_model(BrokerageName.BINANCE, AccountType.MARGIN)
        # In the Binance brokerage, you can't trade with USD.
        # Set the account currency to USDT and add the starting cash.
        self.set_account_currency("USDT", 50_000_000)
        # Add the BTCUSDT spot and Futures markets.
        self._spot = self.add_crypto(
            "BTCUSDT", fill_forward=False, market=Market.BINANCE
        )
        self._future = self.add_crypto_future(
            "BTCUSDT", fill_forward=False, market=Market.BINANCE
        )
        self._multiplier = self._future.symbol_properties.contract_multiplier
        self._threshold = 1.005  # 0.5%
    
    def on_data(self, slice: Slice) -> None:
        # Wait for there to be a TradeBar for each asset, so we know
        # the prices are up-to-date.
        for security in [self._spot, self._future]:
            if security.symbol not in slice.bars:
                return
        spot = self._spot.price
        future = self._future.price
        # Buy low sell high: If one's price is above another by the 
        # set threshold, sell it and buy the other security. The 
        # threshold ensures there is enough profit potential to overcome
        # the fees and slippage. Make sure to equalize the actual order
        # size with the contract multiplier.
        if spot >= future * self._threshold:
            self._enter(-1, 1)
        elif future >= spot * self._threshold:
            self._enter(1, -1)
        # When the mispricing converges, close both positions to earn 
        # the spread.
        elif self._spot.invested:
            # Scan for an exit.
            if ((self._spot.holdings.is_short and spot < future) or
                (self._spot.holdings.is_long and spot > future)):
                # Liquidate the spot position.
                quantity = min(
                    self._spot.holdings.quantity, 
                    self._spot.base_currency.amount
                )
                if quantity < 0:
                    quantity /= (1 - 0.001)  # To cover the taker fees.
                lot_size = self._spot.symbol_properties.lot_size
                self.market_order(
                    self._spot.symbol, 
                    -round(quantity / lot_size) * lot_size, 
                    tag='Liquidate Spot'
                )
                # Liquidate the Future position.
                self.liquidate(self._future.symbol, tag='Liquidate Future')
    
    def _enter(self, spot_sign, future_sign):
        quantity = self.calculate_order_quantity(self._future.symbol, 0.5)
        if not quantity: 
            return
        # Enter the spot position.
        spot_quantity = spot_sign * quantity * self._multiplier
        self.market_order(self._spot.symbol, spot_quantity, tag='Spot')
        # Enter the Future position.
        self.market_order(self._future, future_sign * quantity, tag='Future')
</pre>
 <script class="python-result" type="text">
  {
    "Total Orders": "28",
    "Average Win": "0.82%",
    "Average Loss": "-0.58%",
    "Compounding Annual Return": "2.801%",
    "Drawdown": "1.500%",
    "Expectancy": "0.279",
    "Start Equity": "50000000.00",
    "End Equity": "51404315.08",
    "Net Profit": "2.809%",
    "Sharpe Ratio": "0.428",
    "Sortino Ratio": "1.031",
    "Probabilistic Sharpe Ratio": "64.657%",
    "Loss Rate": "47%",
    "Win Rate": "53%",
    "Profit-Loss Ratio": "1.42",
    "Alpha": "0.01",
    "Beta": "0.001",
    "Annual Standard Deviation": "0.022",
    "Annual Variance": "0.001",
    "Information Ratio": "0.891",
    "Tracking Error": "0.598",
    "Treynor Ratio": "9.822",
    "Total Fees": "\u20ae604654.02",
    "Estimated Strategy Capacity": "\u20ae10000000000000.00",
    "Lowest Capacity Asset": "BTCUSDT 18N",
    "Portfolio Turnover": "3.25%",
    "OrderListHash": "11994c38ba8e98be4c1af38ccaac37bb"
}
 </script>
</div>
