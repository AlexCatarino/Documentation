<p>
 The following examples demonstrate some common practices for requesting Crypto Futures data.
</p>
<h4>
 Example 1: Respect Lot Sizes
</h4>
<p>
 Like Futures, Crypto Futures contracts have a fixed discrete lot size to trade instead of fractional like spot Crypto pairs. 
    The following algorithm demonstrates how to place orders that respect the lot size to avoid rounding errors.
</p>
<div class="section-example-container testable">
 <pre class="csharp">public class CryptoFutureAlgorithm : QCAlgorithm
{
    private Symbol _symbol;

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        // Set brokerage and account type to match your brokerage environment for accurate fee and margin behavior.
        SetBrokerageModel(BrokerageName.Binance, AccountType.Margin);
        // In the Binance brokerage, you can't trade with USD.
        // Set the account currency as USDT and add the starting cash.
        SetAccountCurrency("USDT", 100000);
        // Subscribe to the BTCUSDT perpetual Future contract.
        _symbol = AddCryptoFuture("BTCUSDT").Symbol;
    }
    
    public override void OnData(Slice slice)
    {
        // Only place orders when market is open since market on open orders aren't supported.
        if (!Portfolio.Invested &amp;&amp; IsMarketOpen(_symbol))
        {
            // Get the lot size from the symbol properties. Placing an order that respects the lot size 
            // ensures the order is valid and allows accurate profit and risk calculations for the whole portfolio.
            var lotSize = Securities[_symbol].SymbolProperties.LotSize;
            // This example demonstrates an initial desired order size of 2.5 contracts, which will be rounded 
            // to 2 contracts since the lot size is 1.
            var quantity = Convert.ToDecimal(Math.Floor(2.5 / (double)lotSize)) * lotSize;
            MarketOrder(_symbol, quantity);
        }
    }
}</pre>
 <script class="csharp-result" type="text">
  {
    "Total Orders": "1",
    "Average Win": "0%",
    "Average Loss": "0%",
    "Compounding Annual Return": "552.533%",
    "Drawdown": "15.500%",
    "Expectancy": "0",
    "Start Equity": "100000.00",
    "End Equity": "187228.13",
    "Net Profit": "87.228%",
    "Sharpe Ratio": "10.97",
    "Sortino Ratio": "20.316",
    "Probabilistic Sharpe Ratio": "93.621%",
    "Loss Rate": "0%",
    "Win Rate": "0%",
    "Profit-Loss Ratio": "0",
    "Alpha": "6.697",
    "Beta": "0.352",
    "Annual Standard Deviation": "0.73",
    "Annual Variance": "0.533",
    "Information Ratio": "5.559",
    "Tracking Error": "0.772",
    "Treynor Ratio": "22.718",
    "Total Fees": "\u20ae146.25",
    "Estimated Strategy Capacity": "\u20ae360000.00",
    "Lowest Capacity Asset": "BTCUSDT 18R",
    "Portfolio Turnover": "1.23%",
    "Drawdown Recovery": "20",
    "OrderListHash": "5ee8fb26ba669e7381342400167ecaa4"
}
 </script>
 <pre class="python">class CryptoFutureAlgorithm(QCAlgorithm):

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        # Set brokerage and account type to match your brokerage environment for accurate fee and margin behavior.
        self.set_brokerage_model(BrokerageName.BINANCE, AccountType.MARGIN)
        # In the Binance brokerage, you can't trade with USD.
        # Set the account currency as USDT and add the starting cash.
        self.set_account_currency("USDT", 100_000)
        # Subscribe to the BTCUSDT perpetual Future contract.
        self._symbol = self.add_crypto_future("BTCUSDT").symbol
        
    def on_data(self, slice: Slice) -&gt; None:
        # Only place orders when market is open since market on open orders aren't supported.
        if not self.portfolio.invested and self.is_market_open(self._symbol):
            # Get the lot size from the symbol properties. Placing an order that respects the lot size 
            # ensures the order is valid and allows accurate profit and risk calculations for the whole portfolio.
            lot_size = self.securities[self._symbol].symbol_properties.lot_size
            # This example demonstrates an initial desired order size of 2.5 contracts, which will be rounded 
            # to 2 contracts since the lot size is 1.
            quantity = 2.5 // lot_size * lot_size
            self.market_order(self._symbol, quantity)</pre>
 <script class="python-result" type="text">
  {
    "Total Orders": "1",
    "Average Win": "0%",
    "Average Loss": "0%",
    "Compounding Annual Return": "552.170%",
    "Drawdown": "15.500%",
    "Expectancy": "0",
    "Start Equity": "100000.00",
    "End Equity": "187193.24",
    "Net Profit": "87.193%",
    "Sharpe Ratio": "10.965",
    "Sortino Ratio": "20.305",
    "Probabilistic Sharpe Ratio": "93.621%",
    "Loss Rate": "0%",
    "Win Rate": "0%",
    "Profit-Loss Ratio": "0",
    "Alpha": "6.691",
    "Beta": "0.352",
    "Annual Standard Deviation": "0.73",
    "Annual Variance": "0.532",
    "Information Ratio": "5.551",
    "Tracking Error": "0.772",
    "Treynor Ratio": "22.707",
    "Total Fees": "\u20ae146.20",
    "Estimated Strategy Capacity": "\u20ae360000.00",
    "Lowest Capacity Asset": "BTCUSDT 18R",
    "Portfolio Turnover": "1.23%",
    "Drawdown Recovery": "20",
    "OrderListHash": "71d078f7ea04cedb78d274c868aea6e3"
}
 </script>
</div>
