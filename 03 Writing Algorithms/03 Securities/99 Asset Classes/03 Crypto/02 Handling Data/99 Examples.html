<h4>Example 1: Dollar Cost Average BTC</h4>
<p>Dollar cost averaging (DCA) is a fixed investment in dollar amount on a regular basis (e.g. monthly) regardless of the asset's price. It can smoothen the volatility in PnL due to the averaging of acquisition price of each batch investment. In this example, we demonstrate a dollar cost average investment on BTC. We will invest $1000 USD worth of BTC every midnight EST for 30 consecutive days.</p>
<div class="section-example-container"></div>
	<pre class="csharp">public class CryptoExampleAlgorithm : QCAlgorithm
{
    private Symbol _symbol;
    // Set a day count variable for counting the days of DCA trade.
    private int _dayCount = 0;

    public override void Initialize()
    {
        // Set brokerage and account type to match your brokerage environment for accurate fee and margin behavior.
        SetBrokerageModel(BrokerageName.Bitfinex, AccountType.Cash);
        // For daily DCA investment, subscription to daily data is sufficient.
        // Add subscriptions to cryptos with specific market to ensure the correct securities are selected.
        _symbol = AddCrypto("BTCUSD", Resolution.Daily, Market.Bitfinex).Symbol;
    }

    public override void OnData(Slice slice)
    {
        // If already invested for 30 consecutive days, stop additional investment.
        if (slice.Bars.ContainsKey(_symbol) && _dayCount++ &lt; 30)
        {
            // Calculate the order size for $10000 USD using the current price.
            var size = 10000m / slice.Bars[_symbol].Close;
            MarketOrder(_symbol, size);
        }
    }
}</pre>
	<pre class="python">class CryptoExampleAlgorithm(QCAlgorithm):
    def initialize(self) -&gt; None:
        # Set a day count variable for counting the days of DCA trade.
        self.day_count = 0
        # Set brokerage and account type to match your brokerage environment for accurate fee and margin behavior.
        self.set_brokerage_model(BrokerageName.BITFINEX, AccountType.CASH)
        # For daily DCA investment, subscription to daily data is sufficient.
        # Add subscriptions to cryptos with specific market to ensure the correct securities are selected.
        self._symbol = self.add_crypto("BTCUSD", Resolution.DAILY, Market.BITFINEX).symbol

    def on_data(self, slice: Slice) -&gt; None:
        # If already invested for 30 consecutive days, stop additional investment.
        if self._symbol in slice.bars and self.day_count &lt; 30:
            # Calculate the order size for $10000 USD using the current price.
            size = 10000 / slice.bars[self._symbol].close
            self.market_order(self._symbol, size)
    
            # Add day count.
            self.day_count += 1</pre>
</div>

<h4>Example 2: Inter-market spread</h4>
<p>Always, there exhibit a small discrepancy in price of the same crypto pair trading between different crypto exchanges. Although you cannot live trade different brokerages in the same algorithm, you can study the cointegration pattern and implement 2 live nodes to do arbitration for this inter market spread discrepancy. In the below example, we demonstrate how to obtain this spread between BTCUSD traded in Kraken and Coinbase exchanges.</p>
<div class="section-example-container"></div>
	<pre class="csharp">public class CryptoExampleAlgorithm : QCAlgorithm
{
    private Symbol _krakenBtc;
    private Symbol _coinbaseBtc;

    public override void Initialize()
    {
        // Add subscription of BTC-USD of 2 different exchanges in order to obtain the inter-market spread
        _krakenBtc = AddCrypto("BTCUSD", market: Market.Kraken).Symbol;
        _coinbaseBtc = AddCrypto("BTCUSD", market: Market.Coinbase).Symbol;
    }

    public override void OnData(Slice slice)
    {
        // Only compare the price if prices of both exchanges are updated for fair comparison
        if (slice.Bars.ContainsKey(_krakenBtc) && slice.Bars.ContainsKey(_coinbaseBtc))
        {
            // Calculate the spread between the 2 exchanges, make sure the comparison is always in the same direction
            var spread = slice.Bars[_krakenBtc].Close - slice.Bars[_coinbaseBtc].Close;
            // Plot the spread between the 2 exchanges in a custom plot and series by the plot and series name
            Plot("BTC Close Spread", "Spread", spread);
        }
    }
}</pre>
	<pre class="python">class CryptoExampleAlgorithm(QCAlgorithm):
    def initialize(self) -&gt; None:
        # Add subscription of BTC-USD of 2 different exchanges in order to obtain the inter-market spread.
        self.kraken_btc = self.add_crypto("BTCUSD", market=Market.KRAKEN).symbol
        self.coinbase_btc = self.add_crypto("BTCUSD", market=Market.COINBASE).symbol

    def on_data(self, slice: Slice) -&gt; None:
        # Only compare the price if prices of both exchanges are updated for fair comparison.
        if self.kraken_btc in slice.bars and self.coinbase_btc in slice.bars:
            # Calculate the spread between the 2 exchanges, make sure the comparison is always in the same direction.
            spread = slice.bars[self.kraken_btc].close - slice.bars[self.coinbase_btc].close
            # Plot the spread between the 2 exchanges in a custom plot and series by the plot and series name.
            self.plot("BTC Close Spread", "Spread", spread)</pre>
</div>
