<p>If you need to save data or create objects for each security in the universe, <span class='python'>add custom members to the respective <code>Security</code> objects</span><span class='csharp'>cast the <code>Security</code> objects to <code>dynamic</code> objects and then save custom members to them</span>. This technique is useful if you want to track stop loss levels or add <a href="/docs/v2/writing-algorithms/indicators/key-concepts">indicators</a> for each asset in the universe.</p>


<div class="section-example-container">
<pre class="csharp">// Cast the security as dynamic to add custom properties to the object.
public override void OnSecuritiesChanged(SecurityChanges changes)
{
    foreach (var security in changes.AddedSecurities)
    {
        var dynamicSecurity = security as dynamic;

        // Create an SMA indicator with 10 periods for the asset.
        dynamicSecurity.Indicator = SMA(security.Symbol, 10);

        // Warm up the historical data for the indicator.
        WarmUpIndicator(security.Symbol, dynamicSecurity.Indicator);
    }
    // Remove the indicator in case of security is removed from universe.
    foreach (var security in changes.RemovedSecurities)
    {
        DeregisterIndicator((security as dynamic).Indicator);
    }
}</pre>
<pre class="python"># Add custom properties to the security by adding custom members to the object.
def on_securities_changed(self, changes: SecurityChanges) -> None:
    for security in changes.added_securities:
        # Create an SMA indicator with 10 periods for the asset. Use duck typing to store it on the security class.
        security.indicator = self.sma(security.Symbol, 10)

        # Warm up the historical data for the indicator.
        self.warm_up_indicator(security.symbol, security.indicator)

    # Remove the indicator in case of security is removed from universe.
    for security in changes.removed_securities:
        self.deregister_indicator(security.indicator)</pre>
</div>
