<p>The following examples demonstrate some common practices for Custom Universe.</p>

<h4>Example 1: Sourcing from the Object Store</h4>
<p>
	This project demonstrates how to read custom data from the <a href="/docs/v2/writing-algorithms/object-store">Object Store</a>, and then use it to define a universe and place trades. 
	The following <a href="/docs/v2/research-environment">research environment</a> file generates the demo universe data, which contains a daily set of assets and their respective signals:
</p>
<div class="csharp section-example-container">
    <pre class="csharp">// Load the assembly files and data types in their own cell.
#load "../Initialize.csx"</pre>
</div>

<div class="section-example-container">
    <pre class="csharp">// Import the data types.
#load "../QuantConnect.csx"
using QuantConnect;
using QuantConnect.Research;
using QuantConnect.Data.Market;
using MathNet.Numerics.Distributions;

// Create a QuantBook.
var qb = new QuantBook();
// Make a history request to get a list of trading days.
var history = qb.History<TradeBar>(
    Symbol.Create("SPY", SecurityType.Equity, Market.USA), 
    new DateTime(2015, 1, 1), new DateTime(2024, 12, 31), Resolution.Daily
).ToList();
// Create a variable to store the file contents.
var contents = new List&lt;string&gt;();
// Define the list of possible assets.
var tickers = new List<string> { "SPY", "TLT", "GLD", "USO", "IWM" };
// Loop through the list of trading days.
for (int i = 0; i < history.Count; i++)
{
    // Create a random number generator.
    var random = new Random(i);
    // Select 3 of the assets and define their target portfolio weights.
    var date = history[i].EndTime;
    var equities = tickers.OrderBy(x => random.Next()).Take(3).ToList();
    var weights = Dirichlet.Sample(random, new[] { 10d, 5d, 3d });
    // Append the target portfolio weights for this trading day to the file.
    contents.AddRange(new [] {
        $"{date:yyyy-MM-dd},{equities[0]},{weights[0]}",
        $"{date:yyyy-MM-dd},{equities[1]},{weights[1]}",
        $"{date:yyyy-MM-dd},{equities[2]},{weights[2]}"
    });
}
// Save the file to the Object Store.
Console.WriteLine(qb.ObjectStore.Save("portfolioTargets.csv", string.Join("\n", contents)));</pre>
    <pre class="python"># Set a random seed to ensure reproducibility.
import random
np.random.seed(0)
# Select the asset weights for each trading day.
indices = [[x] * 3 for x in pd.bdate_range('2015-01-01', '2024-12-31')]
weights = list(np.random.dirichlet((10, 5, 3), size=(len(indices),)).flatten())
# Select the universe for each trading day.
equities = []
for i in range(len(indices)):
    random.seed(i)
    equities.extend(list(random.sample(["SPY", "TLT", "GLD", "USO", "IWM"], 3)))
# Organize the data into a DataFrame.
df = pd.DataFrame({"Date": [x for y in indices for x in y], "Symbol": equities, "Weight": weights})
# Save the DataFrame as a CSV in the Object Store.
qb = QuantBook()
file_path = qb.object_store.get_file_path(f"portfolio-targets.csv")
df.to_csv(file_path, index=False)</pre>
</div>

<p>The following algorithm file reads the preceding CSV file from the Object Store and uses its contents to form the daily universe and place trades:</p>
<div class="section-example-container">
    <pre class="csharp">public class CustomUniverseExampleAlgorithm : QCAlgorithm
{
    // Create a dictionary to hold the target weight of each asset..
    private Dictionary&lt;Symbol, decimal&gt; _weightBySymbol = new();
    private Universe _universe;

    public override void Initialize()
    {
        SetStartDate(2015, 1, 1);
        // Add a universe that reads from the Object Store.
        _universe = AddUniverse&lt;CustomUniverseData&gt;("CustomUniverse", Resolution.Daily, (altCoarse) => {
            // Clear the dictionary of asset weights.
            _weightBySymbol.Clear();

            var selected = new List&lt;Symbol&gt;();
            foreach (CustomUniverseData d in altCoarse)
            {
                // Select the symbols that have a significant weight in the custom universe data to avoid 
                // small-size trades that erode returns.
                if (d.Weight > 0.05m)
                {
                    selected.Add(d.Symbol);
                    // Save the weight to use during the rebalance.
                    _weightBySymbol[d.Symbol] = d.Weight;
                }
            }
            return selected;
        });
        // Add a Scheduled Event to rebalance the portfolio.
        var spy = QuantConnect.Symbol.Create("SPY", SecurityType.Equity, Market.USA);
        Schedule.On(
            DateRules.EveryDay(spy), 
            TimeRules.AfterMarketOpen(spy, 1), 
            () => SetHoldings(_universe.Selected.Select(symbol => new PortfolioTarget(symbol, _weightBySymbol[symbol])).ToList(), true)
        );
    }
}

public class CustomUniverseData : BaseData
{
    public decimal Weight;
    public override DateTime EndTime 
    {
        // The universe weight is valid for 1 day.
        get { return Time + QuantConnect.Time.OneDay; }
        set { Time = value - QuantConnect.Time.OneDay; }
    }

    public override SubscriptionDataSource GetSource(SubscriptionDataConfig config, DateTime date, bool isLiveMode)
    {
        // The data is in the Object Store as a CSV.
        return new SubscriptionDataSource("portfolioTargets.csv", SubscriptionTransportMedium.ObjectStore, FileFormat.Csv);
    }

    public override BaseData Reader(SubscriptionDataConfig config, string line, DateTime date, bool isLiveMode) 
    {
        // Skip the header row.
        if (!Char.IsDigit(line[0]))
        {
            return null;
        }

        // CSV data is split by comma.
        var items = line.Split(",");

        // Parse the data from the CSV file.
        return new CustomUniverseData 
        {
            EndTime = Parse.DateTimeExact(items[0], "yyyy-MM-dd"),
            // All the symbols are US Equities.
            Symbol = Symbol.Create(items[1], SecurityType.Equity, Market.USA),
            Weight = decimal.Parse(items[2], NumberStyles.Any, CultureInfo.InvariantCulture)
        };
    }
}</pre>
    <pre class="python">class CustomUniverseExampleAlgorithm(QCAlgorithm):
    # A dictionary to hold the updated weight for position sizing.
    _weight_by_symbol = {}

    def initialize(self) -&gt; None:
        self.set_start_date(2015, 1, 1)
        # Daily weight signals from our custom universe data only requires daily resolution.
        self.universe_settings.resolution = Resolution.DAILY
        # Filter using the custom dataset, our sample data is by daily basis.
        self.add_universe(CustomUniverseData, "CustomUniverse", Resolution.DAILY, self.selector_function)
    
    def selector_function(self, alt_coarse: List[PythonData]) -&gt; List[Symbol]:
        # Clear weight dictionary to avoid outdated signals.
        self._weight_by_symbol.clear()
        
        selected = []
        for d in alt_coarse:
            # Select the symbols that have a significant weight in the custom universe data to avoid small-size trade that friction and fee would erode the return.
            if d["weight"] &gt; 0.05:
            	selected.append(d.symbol)
                # Cache the indicated weight in the custom data for investment size later.
            	self._weight_by_symbol[d.symbol] = d["weight"]

        return selected

    def on_data(self, slice: Slice) -&gt; None:
        # Invest according to the custom data indicated weight. Since the resolution is daily, there is no issue for over rebalancing.
        for symbol, weight in self._weight_by_symbol.items():
            self.set_holdings(symbol, weight)

    def on_securities_changed(self, changes: SecurityChanges) -&gt; None:
        # Liquidate the remove securities to free margin.
        for removed in changes.removed_securities:
            self.liquidate(removed.symbol)
    
class CustomUniverseData(PythonData):
    def get_source(self, config: SubscriptionDataConfig, date: datetime, is_live_mode: bool) -&gt; SubscriptionDataSource:
        # The saved dataframe is in form of CSV saved in the object store.
        return SubscriptionDataSource("df.csv", SubscriptionTransportMedium.OBJECT_STORE, FileFormat.CSV)

    def reader(self, config: SubscriptionDataConfig, line: str, date: datetime, is_live_mode: bool) -&gt; BaseData:
		# Skip header column.
        if not line[0].isnumeric():
            return None
            
        # CSV data is split by comma.
        items = line.split(",")
    
        # Generate required data, then return an instance of your class.
        data = CustomUniverseData()
        data.end_time = datetime.strptime(items[0], "%Y-%m-%d")
        # The universe weight is valid for 1 day.
        data.time = data.end_time - timedelta(1)
        # All the symbols are US Equities.
        data.symbol = Symbol.create(items[1], SecurityType.EQUITY, Market.USA)
        data["weight"] = float(items[2])
        return data</pre>
</div>

<h4>Other Examples</h4>
<p>For more examples, see the following algorithms:</p>
<div class="example-fieldset">
	<div class="example-legend">Demonstration Algorithms</div>
	<a class="python example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.Python/DropboxUniverseSelectionAlgorithm.py" target="_BLANK"> DropboxUniverseSelectionAlgorithm.py  <span class="badge-python pull-right">Python</span></a>
	<a class="csharp example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.CSharp/DropboxUniverseSelectionAlgorithm.cs" target="_BLANK"> DropboxUniverseSelectionAlgorithm.cs  <span class="badge badge-sm badge-csharp pull-right">C#</span></a>
	<a class="python example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.Python/DropboxBaseDataUniverseSelectionAlgorithm.py" target="_BLANK"> DropboxBaseDataUniverseSelectionAlgorithm.py  <span class="badge-python pull-right">Python</span></a>
	<a class="csharp example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.CSharp/DropboxBaseDataUniverseSelectionAlgorithm.cs" target="_BLANK"> DropboxBaseDataUniverseSelectionAlgorithm.cs  <span class="badge badge-sm badge-csharp pull-right">C#</span></a>
</div>
