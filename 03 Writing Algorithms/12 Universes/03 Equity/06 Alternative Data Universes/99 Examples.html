<p>The following examples demonstrate some common alternative data universes.</p>

<h4>Example 1: Brain Sentiment Universe</h4>
<p>
    The following algorithm uses the <a href='/docs/v2/writing-algorithms/datasets/brain/brain-sentiment-indicator'>Brain Sentiment Indicator</a> dataset to create a universe of US Equities that have some article mentions and the most positive sentiment. The selected equities will be invested according to their sentiment score. The more positive the sentiment, the higher the weighting.
</p>
<div class="section-example-container">
	<pre class="csharp">public class BrainSentimentUniverseAlgorithm : QCAlgorithm
{
    // A dictionary to hold the updated sentiment score from the stocks with top sentiment score for position sizing.
    private Dictionary&lt;Symbol, decimal&gt; _sentimentScores = new();

    public override void Initialize()
    {
        SetStartDate(2020, 1, 1);
        // Weekly universe update since the signal is for the next 7 days.
        UniverseSettings.Schedule.On(DateRules.WeekStart());
        // Select from Brain Sentiment dataset by sentiment factor.
        AddUniverse&lt;BrainSentimentIndicatorUniverse&gt;(
            altData =&gt; altData.OfType&lt;BrainSentimentIndicatorUniverse&gt;()
                // Make sure to select from the ones with recent mentions and sentiment score available for filtering and sizing.
                .Where(x =&gt; x.TotalArticleMentions7Days.HasValue &amp;&amp; x.Sentiment7Days.HasValue)
                // Select assets with some mentions and the greatest sentiment to maximize the expected return from sentiment factor.
                .Where(x =&gt; x.TotalArticleMentions7Days &gt; 0)
                .OrderByDescending(x =&gt; x.Sentiment7Days)
                .Take(20)
                // Return the symbols for the selected assets.
                .Select(x =&gt; {
                    // Update sentiment score dictionary to only holds the most updated sentiment score for sizing.
                    _sentimentScores.Clear();
                    _sentimentScores[x.Symbol] = x.Sentiment7Days.Value;
                    return x.Symbol;
                })
        );

        // Weekly rebalance to allow time to digest the 7-day signal.
        Schedule.On(
            DateRules.WeekStart(),
            TimeRules.At(9, 30),
            Rebalance
        );
    }

    private void Rebalance()
    {
        // Calculate the sentiment score sum to normalize them for sizing.
        var sentimentScoreSum = _sentimentScores.Sum(kvp =&gt; kvp.Value);

        foreach (var (symbol, holding) in Portfolio)
        {
            // If it is not the stock with high positive sentiment, liquidate for better opportunities with higher expected return.
            if (holding.Invested &amp;&amp; !_sentimentScores.ContainsKey(symbol))
            {
                Liquidate(symbol);
            }
            // Invest in the top sentiment stocks with sentiment score as size to maximize expected return.
            else if (_sentimentScores.TryGetValue(symbol, out var score))
            {
                SetHoldings(symbol, score / sentimentScoreSum);
            }
        }
    }
}</pre>
	<pre class="python">class BrainSentimentUniverseAlgorithm(QCAlgorithm):
    # A dictionary to hold the updated sentiment score from the stocks with top sentiment score for position sizing.
    _sentiment_scores = {}

    def initialize(self) -&gt; None:
        self.set_start_date(2020, 1, 1)
        # Weekly universe update since the signal is for the next 7 days.
        self.universe_settings.schedule.on(self.date_rules.week_start())
        # Select from Brain Sentiment dataset by sentiment factor.
        self.add_universe(BrainSentimentIndicatorUniverse, self._select_assets)

        # Weekly rebalance to allow time to digest the 7-day signal.
        self.schedule.on(
            self.date_rules.week_start(),
            self.time_rules.at(9, 30),
            self.rebalance
        )
    
    def _select_assets(self, alt_data: List[BrainSentimentIndicatorUniverse]) -&gt; List[Symbol]:
        # Make sure to select from the ones with recent mentions and sentiment score available for filtering and sizing.
        alt_data = [x for x in alt_data if x.total_article_mentions_7_days and x.sentiment_7_days]
        # Select assets with some mentions and the greatest sentiment to maximize the expected return from sentiment factor.
        selected = sorted(alt_data, key=lambda x: x.sentiment_7_days)[-20:]
        # Update sentiment score dictionary to only holds the most updated sentiment score for sizing.
        self._sentiment_scores.clear()
        universe = []
        for datum in selected:
            self._sentiment_scores[datum.symbol] = datum.sentiment_7_days
            universe.append(datum.symbol)
        # Return the symbols for the selected assets.
        return universe
    
    def rebalance(self) -&gt; None:
        # Calculate the sentiment score sum to normalize them for sizing.
        sentiment_score_sum = sum(list(self._sentiment_scores.values()))

        for symbol, holding in self.portfolio.items():
            # If it is not the stock with high positive sentiment, liquidate for better opportunities with higher expected return.
            if holding.invested and symbol not in self._sentiment_scores:
                self.liquidate(symbol)
            # Invest in the top sentiment stocks with sentiment score as size to maximize expected return.
            elif symbol in self._sentiment_scores:
                self.set_holdings(symbol, self._sentiment_scores[symbol] / sentiment_score_sum)</pre>
</div>

<h4>Example 2: Insiders Trading Universe</h4>
<p>
	Insiders have more information to evaluate the overall prospect of the company, so following their trades can be useful. 
	The following algorithm uses the <a href='/docs/v2/writing-algorithms/datasets/quiver-quantitative/insider-trading'>Insider Trading</a> to create a universe of US Equities that insiders have recently purchased.
    We invest equally into the companies with positive insider trades, which may provide extra confidence in their expected return, and hold for 3 months.
</p>
<div class="section-example-container">
	<pre class="csharp">public class InsiderTradingUniverseAlgorithm : QCAlgorithm
{
    private List&lt;Symbol&gt; _universe = new();

    public override void Initialize()
    {
        // Keep each security in the universe for a minimum of 30 days to digest the insiders purchase sentiment.
        UniverseSettings.MinimumTimeInUniverse = TimeSpan.FromDays(30);
        // Using QuiverInsiderTrading dataset for insider trade detection and filtering.
        AddUniverse&lt;QuiverInsiderTradingUniverse&gt;(altData =&gt;
        {
            // Select assets that insiders have purchased, which may provide extra confidence in their expected return.
            return from d in altData.OfType&lt;QuiverInsiderTradingUniverse&gt;()
                   where d.SharesOwnedFollowing.HasValue &amp;&amp; d.Shares.HasValue
                   &amp;&amp; d.SharesOwnedFollowing.Value &gt; 0m &amp;&amp; d.Shares.Value &gt; 0m
                   select d.Symbol;
        });
    }
    
    public override void OnSecuritiesChanged(SecurityChanges changes)
    {
        // Update universe to trade.
        _universe.AddRange(changes.AddedSecurities.Select(x =&gt; x.Symbol).ToList());
        // Equally invest in insider buying companies to evenly dissipate the capital risk.
        SetHoldings(_universe.Select(x =&gt; new PortfolioTarget(x, 1m / _universe.Count)).ToList());

        // Liquidate and remove from universe for the ones not being recently-purchase by insiders.
        foreach (var removed in changes.RemovedSecurities)
        {
            Liquidate(removed.Symbol);
            _universe.Remove(removed.Symbol);
        }
    }
}</pre>
	<pre class="python">class InsiderTradingUniverseAlgorithm(QCAlgorithm):
    _universe = []

    def initialize(self) -&gt; None:
        # Keep each security in the universe for a minimum of 30 days to digest the insiders purchase sentiment.
        self.universe_settings.minimum_time_in_universe = timedelta(30)
        # Using QuiverInsiderTrading dataset for insider trade detection and filtering.
        # Select assets that insiders have purchased, which may provide extra confidence in their expected return.
        self.add_universe(
            QuiverInsiderTradingUniverse, 
            lambda alt_data: [x.symbol for x in alt_data if x.shares and x.shares &gt; 0]
        )
        
    def on_securities_changed(self, changes: SecurityChanges) -&gt; None:
        # Update universe to trade.
        self._universe.extend([x.symbol for x in changes.added_securities])
        # Equally invest in insider buying companies to evenly dissipate the capital risk.
        self.set_holdings([PortfolioTarget(x, 1. / len(self._universe)) for x in self._universe])

        # Liquidate and remove from universe for the ones not being recently-purchase by insiders.
        for removed in changes.removed_securities:
            self.liquidate(removed.symbol)
            if removed.symbol in self._universe:
                self._universe.remove(removed.symbol)</pre>
</div>

<h4>Example 3: Share Buyback Universe</h4>
<p>The following algorithm uses the <a href='/docs/v2/writing-algorithms/datasets/smart-insider/corporate-buybacks'>Corporate Buybacks</a> dataset to create a universe of US Equities that have announced an upcoming share buyback program:</p>
<div class="section-example-container">
	<pre class="csharp">public class InsiderTradingUniverseAlgorithm : QCAlgorithm
{
    // A dictionary to hold the updated buyback size for position sizing.
    public Dictionary&lt;Symbol, decimal&gt; _buybackSize = new();

    public override void Initialize()
    {
        SetStartDate(2021, 1, 1);
        SetSecurityInitializer(
            new BrokerageModelSecurityInitializer(BrokerageModel, new FuncSecuritySeeder(GetLastKnownPrices))
        );
        // Filter for any coporate announced a material buyback plan, since they have confidence in their future prospect and the reduction in supply can drive their price up.
        AddUniverse&lt;SmartInsiderIntentionUniverse&gt;(
            altData =&gt; altData.OfType&lt;SmartInsiderIntentionUniverse&gt;()
                // A material buyback size to have better confidence in its prospect.
                .Where(d =&gt; d.AmountValue.HasValue &amp;&amp; d.AmountValue.Value &gt;= 5000000m)
                .Select(d =&gt; {
                    // Update buyback size dictionary for sizing.
                    _buybackSize[d.Symbol] = d.AmountValue.Value;
                    return d.Symbol;
                })
        );
    }
    
    public override void OnSecuritiesChanged(SecurityChanges changes)
    {
        // Get the size of all buyback size to normalize the weightings.
        var buybackSum = _buybackSize.Sum(x =&gt; x.Value);
        // Equally invest in insider buying companies to evenly dissipate the capital risk.
        SetHoldings(_buybackSize.Select(x =&gt; new PortfolioTarget(x.Key, x.Value / buybackSum)).ToList());

        // Liquidate and remove from universe for the ones not being recently-purchase by insiders.
        foreach (var removed in changes.RemovedSecurities)
        {
            Liquidate(removed.Symbol);
        }
    }
}</pre>
	<pre class="python">class InsiderTradingUniverseAlgorithm(QCAlgorithm):
    _buyback_size = {}

    def initialize(self) -&gt; None:
        self.set_start_date(2021, 1, 1)
        self.set_security_initializer(
            BrokerageModelSecurityInitializer(self.brokerage_model, FuncSecuritySeeder(self.get_last_known_prices))
        )
        # Filter for any coporate announced a material buyback plan, since they have confidence in their future prospect and the reduction in supply can drive their price up.
        self.add_universe(SmartInsiderIntentionUniverse, self.intention_selection)
    
    def intention_selection(self, alt_coarse: List[SmartInsiderIntentionUniverse]) -&gt; List[Symbol]:
        selected = []
        
        for d in alt_coarse:
            # A material buyback percentage size to have better confidence in its prospect.
            if d.amount_value and d.amount_value &gt; 5000000:
                # Update buyback size dictionary for sizing.
                self._buyback_size[d.symbol] = d.amount_value
                selected.append(d.symbol)

        return selected
        
    def on_securities_changed(self, changes: SecurityChanges) -&gt; None:
        # Liquidate and remove from universe for the ones not being recently-purchase by insiders.
        for removed in changes.removed_securities:
            self.liquidate(removed.symbol)
            if removed.symbol in self._buyback_size:
                self._buyback_size.pop(removed.symbol)
        
        # Get the size of all buyback size to normalize the weightings.
        buyback_sum = sum(self._buyback_size.values())
        # Equally invest in insider buying companies to evenly dissipate the capital risk.
        self.set_holdings([PortfolioTarget(symbol, size / buyback_sum) for symbol, size in self._buyback_size.items()])</pre>
</div>
