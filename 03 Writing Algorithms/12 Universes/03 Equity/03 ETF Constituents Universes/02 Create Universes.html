<p>To add an ETF Constituents universe, call the <code>Universe.ETF</code> method.</p>

<div class="section-example-container">
<pre class="csharp">public class ETFConstituentsAlgorithm : QCAlgorithm
{
    public override void Initialize() 
    {
        UniverseSettings.Asynchronous = true;
        AddUniverse(Universe.ETF("SPY"));
    }
}</pre>
<pre class="python">class ETFConstituentsAlgorithm(QCAlgorithm):
    def Initialize(self) -&gt; None:
        self.UniverseSettings.Asynchronous = True        
        self.AddUniverse(self.Universe.ETF("SPY"))</pre>
</div>

<p>The following table describes the <code>ETF</code> method arguments:</p>

<table class='qc-table table vertical-table'>
    <tbody>
            <tr>
                <td>
                    <h4>Argument: <span><code>etfTicker</code></span></h4>
                    <p class='property-description'>The ETF ticker. To view the supported ETFs in the US ETF Constituents dataset, see <a href='/docs/v2/writing-algorithms/datasets/quantconnect/us-etf-constituents#06-Supported-ETFs'>Supported ETFs</a>.</p>
                    <p>Data Type: <span><code class="csharp">string</code><code class="python">str</code></span><span class='pipe-separator'>  |  </span> Default Value: <span><code>None</code></span></p>
                </td>
            </tr>
            <tr>
                <td>
                    <h4>Argument: <span><code>universeSettings</code></span></h4>
                    <p class='property-description'>The <a href="https://www.quantconnect.com/docs/v2/writing-algorithms/universes/settings">universe settings</a>. If you don't provide an argument, it uses the algorithm <code>UniverseSettings</code>.</p>
                    <p>Data Type: <span><code>UniverseSettings</code></span><span class='pipe-separator'>  |  </span> Default Value: <span><code>None</code></span></p>
                </td>
            </tr>
            <tr>
                <td>
                    <h4>Argument: <span><code>universeFilterFunc</code></span></h4>
                    <p class='property-description'>A function to select some of the ETF constituents for the universe. If you don't provide an argument, it selects all of the constituents.</p>
                    <p>Data Type: <span><code class="csharp">Func&lt;IEnumerable&lt;ETFConstituentUniverse&gt;, IEnumerable&lt;Symbol&gt;&gt;</code><code class="python">Callable[[List[ETFConstituentUniverse]], List[Symbol]]</code></span><span class='pipe-separator'>  |  </span> Default Value: <span><code class="csharp">null</code><code class="python">None</code></span></p>
                </td>
            </tr>
    </tbody>
</table>

<p>To select a subset of the ETF constituents, provide a <code>universeFilterFunc</code> argument. The filter function receives <code>ETFConstituentUniverse</code> objects, which represent one of the ETF constituents. <code>ETFConstituentUniverse</code> objects have the following attributes:</p>

<div data-tree="QuantConnect.Data.UniverseSelection.ETFConstituentUniverse"></div>


<div class="section-example-container">
<pre class="csharp">public class ETFConstituentsAlgorithm : QCAlgorithm 
{
    private Universe _universe;
    public override void Initialize() 
    {
        UniverseSettings.Asynchronous = true;
        _universe = Universe.ETF("SPY", Market.USA, UniverseSettings, ETFConstituentsFilter);
        AddUniverse(_universe);
    }

    private IEnumerable&lt;Symbol&gt; ETFConstituentsFilter(IEnumerable&lt;ETFConstituentUniverse&gt; constituents)
    {
        // Get the 10 securities with the largest weight in the index
        return constituents.OrderByDescending(c =&gt; c.Weight).Take(10).Select(c =&gt; c.Symbol);
    }
}
</pre>
<pre class="python">class ETFConstituentsAlgorithm(QCAlgorithm):
    def Initialize(self) -&gt; None:
        self.UniverseSettings.Asynchronous = True
        self.universe = self.Universe.ETF("SPY", Market.USA, self.UniverseSettings, self.ETFConstituentsFilter)
        self.AddUniverse(self.universe)

    def ETFConstituentsFilter(self, constituents: List[ETFConstituentUniverse]) -&gt; List[Symbol]:
        # Get the 10 securities with the largest weight in the index
        selected = sorted([c for c in constituents if c.Weight],
            key=lambda c: c.Weight, reverse=True)[:10]
        return [c.Symbol for c in selected]</pre>
</div>
