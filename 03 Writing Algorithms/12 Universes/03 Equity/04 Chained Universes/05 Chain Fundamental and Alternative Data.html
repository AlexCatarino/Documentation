<p>The following example chains a <a href='/docs/v2/writing-algorithms/universes/equity/fundamental-universes'>fundamental universe</a> and a <a href='/docs/v2/writing-algorithms/datasets/quiver-quantitative/cnbc-trading#10-Universe-Selection'>QuiverCNBCsUniverse alternative universe</a>. It first selects the 100 most liquid US Equities and then filters them down to those mentioned by CNBC commentator/trader Jim Cramer. The output of the alternative universe selection method is the output of the chained universe.</p>
<div class="section-example-container">
    <pre class="csharp">#region imports
    using System.Collections.Generic;
    using System.Linq;
    using QuantConnect.Util;
    using QuantConnect.Data;
    using QuantConnect.DataSource;
    using QuantConnect.Data.UniverseSelection;
    using QuantConnect.Securities;
#endregion
    
namespace QuantConnect.Algorithm.CSharp
{
    public class ChainedUniverseAlgorithm : QCAlgorithm
    {
        private List&lt;Symbol&gt; _fundamental = new();

        public override void Initialize()
        {
            SetStartDate(2023, 1, 2);
            SetCash(100000);
            UniverseSettings.Asynchronous = true;
            AddUniverse(fundamental =>
            {
                _fundamental = (from c in fundamental
                    orderby c.DollarVolume descending
                    select c.Symbol).Take(100).ToList();
                return Universe.Unchanged;
            });
            AddUniverse&lt;QuiverCNBCsUniverse&gt;(altCoarse =>
            {
                var followers = from d in altCoarse.OfType&lt;QuiverCNBCsUniverse&gt;()
                    where d.Traders.ToLower().Contains("cramer")
                    select d.Symbol;
                return _fundamental.Intersect(followers);
            });
        }

        public override void OnSecuritiesChanged(SecurityChanges changes)
        {
            foreach (var added in changes.AddedSecurities)
            {
                AddData&lt;QuiverCNBCs&gt;(added.Symbol);
            }
        }
    
        public override void OnData(Slice data)
        {
            foreach (var dataPoint in data.Get&lt;QuiverCNBCs&gt;().SelectMany(x=> x.Value.OfType<QuiverCNBC>()))
            {
                Debug($"{dataPoint.Symbol} traders at {data.Time}: {dataPoint.Traders}");
            }
        }
    }
}</pre>
    <pre class="python"># region imports
    from AlgorithmImports import * 
#endregion

class ChainedUniverseAlgorithm(QCAlgorithm):

    fundamental = []

    def Initialize(self):
        self.SetStartDate(2023, 1, 2)
        self.SetCash(100000)
        self.UniverseSettings.Asynchronous = True
        self.AddUniverse(self.FundamentalFilterFunction)
        self.AddUniverse(QuiverCNBCsUniverse, self.MadMoneySelection)
    
    def FundamentalFilterFunction(self, fundamental: List[Fundamental]) -> List[Symbol]:
        sorted_by_dollar_volume = sorted(fundamental, key=lambda x: x.DollarVolume, reverse=True) 
        self.fundamental = [c.Symbol for c in sorted_by_dollar_volume[:100]]
        return Universe.Unchanged
    
    def MadMoneySelection(self, alt_coarse: List[QuiverCNBCsUniverse]) -> List[Symbol]:
        madmoney = [d.Symbol for d in alt_coarse if 'Cramer' in d.Traders]
        return list(set(self.fundamental) & set(madmoney))
    
    def OnSecuritiesChanged(self, changes):
        for added in changes.AddedSecurities:
            self.AddData(QuiverCNBCs, added.Symbol)
    
    def OnData(self, data):
        # Prices in the slice from the universe selection
        # Alternative data in slice from OnSecuritiesChanged Addition
        # for ticker,bar in data.Bars.items():
        #     pass
        for dataset_symbol, data_points in data.Get(QuiverCNBCs).items():
            for data_point in data_points:
                self.Debug(f"{dataset_symbol} traders at {data.Time}: {data_point.Traders}")</pre>
</div>