<p>The following examples demonstrate some common liquidity universes for US Equities.</p>

<h4>Example 1: Minute-Resolution Liquid Universe</h4>
<p>The following example <a href='/docs/v2/writing-algorithms/universes/settings#09-Asynchronous-Selection'>asynchronously selects</a> the 10 most liquid US Equities and subscribes to <a href='/docs/v2/writing-algorithms/universes/settings#02-Resolution'>minute data</a>:</p>
<div class="section-example-container">
	<pre class="csharp">public class MinuteLiquidUniverseAlgorithm : QCAlgorithm
{
    public override void Initialize()
    {
        // Using asynchronous universe settings can efficiently use the computational resources.
        UniverseSettings.Asynchronous = true;
        // Minute resolution data can have orders filled more realistic and avoid stale fill.
        UniverseSettings.Resolution = Resolution.Minute;
        // Add top 10 dollar volume universe to trade on the most liquid equities, which has the most informed information from market activities.
        AddUniverse(Universe.DollarVolume.Top(10));
    }
}</pre>
	<pre class="python">class MinuteLiquidUniverseAlgorithm(QCAlgorithm):

    def initialize(self) -&gt; None:
        # Using asynchronous universe settings can efficiently use the computational resources.
        self.universe_settings.asynchronous = True
        # Minute resolution data can have orders filled more realistic and avoid stale fill.
        self.universe_settings.resolution = Resolution.MINUTE
        # Add top 10 dollar volume universe to trade on the most liquid equities, which has the most informed information from market activities.
        self.add_universe(self.universe.dollar_volume.top(10))</pre>
</div>

<h4>Example 2: Low Bollinger Bands Liquid Universe</h4>
<p>The following example <a href='/docs/v2/writing-algorithms/universes/settings#09-Asynchronous-Selection'>asynchronously selects</a> the 500 most liquid stocks. Among them, select the ones with 20-day Bollinger Bands below 2 standard deviations. Place <a href="">market-on-open orders</a> and bet them to revert to mean.</p>
<div class="section-example-container">
	<pre class="csharp">public class AsynchronousLiquidUniverseAlgorithm : QCAlgorithm
{
    private Dictionary&lt;Symbol, BollingerBands&gt; _bbBySymbols = new();
    
    public override void Initialize()
    {
        // Using asynchronous universe settings can efficiently use the computational resources.
        UniverseSettings.Asynchronous = true;
        // Subscribe to daily data for speed, accuracy is not affected since the trading frequency is only at daily market open.
        UniverseSettings.Resolution = Resolution.Daily;
        AddUniverse(Selection);
    }

    private IEnumerable&lt;Symbol&gt; Selection(IEnumerable&lt;Fundamental&gt; fundamental)
    {
        // Filter the top 500 most liquid equities for further filtering later.
        // They trade more efficiently and have the most informed information from market activities for later filtering.
        var top500DollarVolume = fundamental.OrderByDescending(f =&gt; f.DollarVolume)
            .Take(500)
            .ToList();
        
        // Remove the non-liquid ones from the dictionary, since they are not traded anymore.
        var nonLiquid = _bbBySymbols.Keys
            .Except(top500DollarVolume.Select(x =&gt; x.Symbol).ToList())
            .ToList();
        foreach (var symbol in nonLiquid)
        {
            _bbBySymbols.Remove(symbol);
        }

        // Update the BB indicators for the liquid stocks.
        foreach (var f in top500DollarVolume)
        {
            // Create the BB indicator for filtering if not exists.
            if (!_bbBySymbols.TryGetValue(f.Symbol, out var bb))
            {
                bb = _bbBySymbols[f.Symbol] = new(60, 2);
                // Warm up indicator to make it readily usable for filtering.
                var history = History&lt;TradeBar&gt;(f.Symbol, 60, Resolution.Daily);
                foreach (var bar in history)
                {
                    bb.Update(bar.EndTime, bar.Close);
                }
            }
            // Normal updating using the latest price if exists.
            else
            {
                bb.Update(Time, f.Price);
            }
        }

        // Select the bottom 100 BB stocks, as predicted that their price will mean-revert up.
        var bottom100BB = _bbBySymbols.OrderBy(kvp =&gt; kvp.Value)
            .Take(100)
            .Select(kvp =&gt; kvp.Key)
            .ToList();
        // Place market-on-open orders to bet their mean-reversion
        foreach (var symbol in bottom100BB)
        {
            MarketOnOpenOrder(symbol, 10);
        }

        return bottom100BB;
    }
}</pre>
	<pre class="python">class AsynchronousLiquidUniverseAlgorithm(QCAlgorithm):

    bb_by_symbols = {}

    def initialize(self) -&gt; None:
        # Using asynchronous universe settings can efficiently use the computational resources.
        self.universe_settings.asynchronous = True
        # Subscribe to daily data for speed, accuracy is not affected since the trading frequency is only at daily market open.
        self.universe_settings.resolution = Resolution.DAILY
        self.add_universe(self.selection)
    
    def selection(self, fundamental: List[Fundamental]) -&gt; List[Symbol]:
        # Filter the top 500 most liquid equities for further filtering later.
        # They trade more efficiently and have the most informed information from market activities for later filtering.
        top_500_dollar_volume = sorted(fundamental, key=lambda f: f.dollar_volume, reverse=True)[:500]
    
        # Remove the non-liquid ones from the dictionary, since they are not traded anymore.
        non_liquid = [symbol for symbol in self.bb_by_symbols if symbol not in [f.symbol for f in top_500_dollar_volume]]
        for symbol in non_liquid:
            del self.bb_by_symbols[symbol]
        
        # Update the BB indicators for the liquid stocks.
        for f in top_500_dollar_volume:
            # Create the BB indicator for filtering if not exists.
            if f.symbol not in self.bb_by_symbols:
                self.bb_by_symbols[f.symbol] = BollingerBands(60, 2, Resolution.DAILY)
                # Warm up indicator to make it readily usable for filtering.
                history = self.history[TradeBar](f.symbol, 60, Resolution.DAILY)
                for bar in history:
                    self.bb_by_symbols[f.symbol].update(bar.end_time, bar.close)
            # Normal updating using the latest price if exists.
            else:
                self.bb_by_symbols[f.symbol].update(self.time, f.price)
            
        # Select the bottom 100 BB stocks, as predicted that their price will mean-revert up.
        bottom_100_bb = [x[0] for x in sorted(self.bb_by_symbols.items(), key=lambda x: x[1].current.value)[:100]]
        # Place market-on-open orders to bet their mean-reversion
        for symbol in bottom_100_bb:
            self.market_on_open_order(symbol, 10)

        return bottom_100_bb</pre>
</div>

<p>For more examples, see the following algorithms:</p>
<div class="example-fieldset">
	<div class="example-legend">Demonstration Algorithms</div>
  <a class="python example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.Python/UniverseSelectionDefinitionsAlgorithm.py" target="_BLANK">UniverseSelectionDefinitionsAlgorithm.py  <span class="badge-python pull-right">Python</span></a>
  <a class="csharp example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.CSharp/UniverseSelectionDefinitionsAlgorithm.cs" target="_BLANK">UniverseSelectionDefinitionsAlgorithm.cs  <span class="badge badge-sm badge-csharp pull-right">C#</span></a>
</div>
