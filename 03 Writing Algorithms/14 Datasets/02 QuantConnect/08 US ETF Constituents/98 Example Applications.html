<p>The ETF Constituents dataset provides an excellent source of tradable universes for strategies without selection bias. When you use an ETF universe, the original ETF can serve as an excellent benchmark for your strategy performance. Other use cases include the following:
</p>
<ul><li>Creating an index-tracking algorithm for customized passive portfolio management</li>
<li>Performing statistical arbitrage with the base ETF</li>
</ul>
<h4>Classic Algorithm Example</h4>
<p>The following example algorithm creates a dynamic universe of the 10 largest US Equities in the SPY ETF. Each day, the algorithm forms a dollar-neutral and market-neutral portfolio by buying the 10 ETF constituents and shorting the SPY ETF.</p>

<div class="section-example-container testable">
<pre class="python">from AlgorithmImports import *


class ETFConstituentUniverseAlgorithm(QCAlgorithm):

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        self.set_cash(100000)
        # Add the SPY to trade.
        self._spy = self.add_equity("SPY").symbol
        # Add an ETF constituents universe that selects the large caps 
        # in SPY. Save the universe object so you can get history
        # for the universe.
        universe = self.add_universe(
            self.universe.etf(
                self._spy, 
                universe_filter_func=self._select_assets
            )
        )
        # Get historical universe data.
        history = self.history(universe, 30, Resolution.DAILY, flatten=True)
        # Show an example of wrangling the historical data.
        etf_weights = history.weight.unstack(1)  
        # Create a dictionary to store the ETF weights each day.
        self._weight_by_symbol = {}
        # Add a Scheduled Event to rebalance the portfolio each day.
        self.schedule.on(
            self.date_rules.every_day(self._spy),
            self.time_rules.after_market_open(self._spy, 1),
            self._rebalance
        )

    def _select_assets(
            self, constituents: List[ETFConstituentUniverse]) -&gt; List[Symbol]:
        # Select the 10 largest stocks in the SPY.
        selected = sorted(
            [c for c in constituents if c.weight], 
            key=lambda c: c.weight
        )[-10:]
        # Save the weights for position sizing.
        self._weight_by_symbol = {c.symbol: c.weight for c in selected}
        # Return the selected assets.
        return list(self._weight_by_symbol.keys())

    def _rebalance(self) -&gt; None:
        # Create a long-short portfolio to earn the excess return of the 
        # top 10 weighted stocks from SPY.
        spy_weight = sum(self._weight_by_symbol.values())
        targets = [PortfolioTarget(self._spy, -0.5)]
        for symbol, weight in self._weight_by_symbol.items():
            targets.append(PortfolioTarget(symbol, 0.5*weight/spy_weight))
        # Liquidate the stocks that aren't in top 10.
        self.set_holdings(targets, True)
</pre>
<pre class="csharp">public class ETFConstituentUniverseAlgorithm : QCAlgorithm
{ 
    private Symbol _spy;
    // Create a dictionary to store the ETF weights each day.
    private Dictionary&lt;Symbol, decimal&gt; _weightBySymbol = new();
    
    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        SetCash(100000);
        // Add the SPY to trade.
        _spy = AddEquity("SPY").Symbol;
        // Add an ETF constituents universe that selects the large caps 
        // in SPY. Save the universe object so you can get history
        // for the universe.
        var universe = AddUniverse(Universe.ETF(_spy, universeFilterFunc: SelectAssets));
        // Get historical universe data.
        var history = History(universe, 30, Resolution.Daily);
        // Show an example of iterating through the historical data.
        foreach (var constituents in history)
        {
            var t = constituents.EndTime;
            foreach (ETFConstituentUniverse constituent in constituents)
            {
                var symbol = constituent.Symbol;
                var weight = constituent.Weight;
            }
        }
        // Add a Scheduled Event to rebalance the portfolio each day.
        Schedule.On(DateRules.EveryDay(_spy), TimeRules.AfterMarketOpen(_spy, 1), Rebalance);
    }
    
    private IEnumerable&lt;Symbol&gt; SelectAssets(IEnumerable&lt;ETFConstituentUniverse&gt; constituents)
    {
        // Select the 10 largest stocks in the SPY. 
        _weightBySymbol = constituents.OrderByDescending(c =&gt; c.Weight).Take(10)
            // Save the weights for position sizing.
            .ToDictionary(c =&gt; c.Symbol, c =&gt; c.Weight ?? 0m);
        // Return the selected assets.
        return _weightBySymbol.Keys;
    }
    
    private void Rebalance()
    {
        // Create a long-short portfolio to earn the excess return of the 
        // top 10 weighted stocks from SPY.
        var spyWeight = _weightBySymbol.Values.Sum();
        var targets = new List&lt;PortfolioTarget&gt;() { new PortfolioTarget(_spy, -0.5m) };
        foreach (var kvp in _weightBySymbol)
        {
            targets.Add(new PortfolioTarget(kvp.Key, 0.5m * kvp.Value / spyWeight));
        }
        // Liquidate the stocks that aren't in top 10.
        SetHoldings(targets, true);
    }
}</pre>
</div>
<h4>Framework Algorithm Example</h4>
<p>The following example algorithm creates a dynamic universe of the 10 largest US Equities in the SPY ETF. Each day, the algorithm forms a dollar-neutral and market-neutral portfolio by buying the 10 ETF constituents and shorting the SPY ETF.</p>

<div class="section-example-container testable">
<pre class="python">class ETFConstituentUniverseFrameworkAlgorithm(QCAlgorithm):

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        self.set_cash(100000)
        self.universe_settings.asynchronous = True
        self.universe_settings.resolution = Resolution.MINUTE
        self.weight_by_symbol = {}
        
        # Add universe selection on SPY's constituents to select only from large cap stocks
        # Save the universe to access its members for historical data call
        spy = self.add_equity("SPY").symbol
        self.add_universe_selection(ETFConstituentsUniverseSelectionModel(spy, self.universe_settings, self.etf_constituents_filter))

        # Add alpha model that set normalized weight as investment insight
        self.add_alpha(ETFConstituentsAlphaModel(self, spy))

        # Set up portfolio construction model that invest by the insight weights
        pcm = InsightWeightingPortfolioConstructionModel()
        # Avoid excessive rebalance on insight changes
        pcm.rebalance_on_insight_changes = False
        self.set_portfolio_construction(pcm)

        self.add_risk_management(NullRiskManagementModel())

        self.set_execution(ImmediateExecutionModel())

    def etf_constituents_filter(self, constituents: List[ETFConstituentUniverse]) -&gt; List[Symbol]:
        # The top 10 weighted securities are considered better active selections
        # Save the weights for position sizing
        selected = sorted([c for c in constituents if c.weight],
            key=lambda c: c.weight, reverse=True)[:10]
        self.weight_by_symbol = {c.symbol: c.weight for c in selected}

        return list(self.weight_by_symbol.keys())

class ETFConstituentsAlphaModel(AlphaModel):

    def __init__(self, algorithm: QCAlgorithm, etf: Symbol) -&gt; None:
        self.algorithm = algorithm
        self.etf = etf
        self.day = -1

    def update(self, algorithm: QCAlgorithm, slice: Slice) -&gt; List[Insight]:
        # Rebalance daily since selection is on daily basis
        if self.day == algorithm.time.day:
            return []

        self.day = algorithm.time.day

        insights = []

        # Create a long-short portfolio to earn excess return of the top 10 weighted stocks from SPY
        etf_weight = sum(self.algorithm.weight_by_symbol.values())
        if etf_weight&gt; 0:
            # Invest half the portfolio by normalized weights of the top 10 constituents
            for symbol, weight in self.algorithm.weight_by_symbol.items():
                if algorithm.securities.contains_key(symbol):
                    insights.append(Insight.price(symbol, Expiry.END_OF_DAY, InsightDirection.UP, weight=0.5*weight/etf_weight))
            
            # Short the other half with SPY, looking to profit from the active selection
            insights.append(Insight.price(self.etf, Expiry.END_OF_DAY, InsightDirection.DOWN, weight=0.5))

        return insights

    def on_securities_changed(self, algorithm: QCAlgorithm, changes: SecurityChanges) -&gt; None:
        # Liquidate the ones not in top 10 weights
        symbols = [x.symbol for x in changes.removed_securities if x.invested]
        algorithm.liquidate(symbols, tag='Removed From Universe')</pre>
<pre class="csharp">public class ETFConstituentUniverseFrameworkAlgorithm : QCAlgorithm
{ 
    public Dictionary&lt;Symbol, decimal&gt; WeightBySymbol = [];
    
    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        SetCash(100000);
        UniverseSettings.Asynchronous = true;
        UniverseSettings.Resolution = Resolution.Minute;

        // Add universe selection on SPY's constituents to select only from large cap stocks
        // Save the universe to access its members for historical data call
        var spy = AddEquity("SPY").Symbol;
        AddUniverseSelection(new ETFConstituentsUniverseSelectionModel(spy, UniverseSettings, ETFConstituentsFilter));
        
        // Add alpha model that set normalized weight as investment insight
        AddAlpha(new ETFConstituentsAlphaModel(this, spy));

        // Set up portfolio construction model that invest by the insight weights
        SetPortfolioConstruction(new InsightWeightingPortfolioConstructionModel
        {
            // Avoid excessive rebalance on insight changes
            RebalanceOnInsightChanges = false
        });
        
        AddRiskManagement(new NullRiskManagementModel());
        
        SetExecution(new ImmediateExecutionModel());
    }
    
    private IEnumerable&lt;Symbol&gt; ETFConstituentsFilter(IEnumerable&lt;ETFConstituentUniverse&gt; constituents)
    {
        // The top 10 weighted securities are considered better active selections
        // Save the weights for position sizing
        WeightBySymbol = constituents.Where(c=&gt; c.Weight.HasValue).OrderByDescending(c =&gt; c.Weight).Take(10)
            .ToDictionary(c =&gt; c.Symbol, c =&gt; c.Weight.Value);

        return WeightBySymbol.Keys;
    }
}

public class ETFConstituentsAlphaModel : AlphaModel
{
    private int _day = -1;
    private Symbol _etf;
    private ETFConstituentUniverseFrameworkAlgorithm _algorithm;
    
    public ETFConstituentsAlphaModel(ETFConstituentUniverseFrameworkAlgorithm algorithm, Symbol etf)
    {
        _etf = etf;
        _algorithm = algorithm;
    }
    
    public override IEnumerable&lt;Insight&gt; Update(QCAlgorithm algorithm, Slice slice)
    {
        // Rebalance daily since selection is on daily basis
        if (_day == algorithm.Time.Day)
        {
            return [];
        }
        
        _day = algorithm.Time.Day;
        
        var insights = new List&lt;Insight&gt;();
        
        // Create a long-short portfolio to earn excess return of the top 10 weighted stocks from SPY
        var etfWeight = (double)_algorithm.WeightBySymbol.Values.Sum();
        if (etfWeight &gt; 0)
        {
            // Invest half the portfolio by normalized weights of the top 10 constituents
            foreach(var kvp in _algorithm.WeightBySymbol)
            {
                insights.Add(Insight.Price(kvp.Key, Expiry.EndOfDay, InsightDirection.Up, weight: (double)kvp.Value/etfWeight * 0.5));
            }

            // Short the other half with SPY, looking to profit from the active selection
            insights.Add(Insight.Price(_etf, Expiry.EndOfDay, InsightDirection.Down, weight: 0.5));
        }
        
        return insights;
    }
    
    public override void OnSecuritiesChanged(QCAlgorithm algorithm, SecurityChanges changes)
    {
        // Liquidate the ones not in top 10 weights
        var symbols = changes.RemovedSecurities.Where(x =&gt; x.Invested).Select(x =&gt; x.Symbol);
        algorithm.Liquidate(symbols, tag: "Removed From Universe");
    }
}</pre>
</div>
<h4>Research Example</h4>
<p>The following example lists ETF constituents with the greatest weight in the SPY:</p>

<div class="section-example-container">
        <pre class="csharp">var qb = new QuantBook();

// Add the ETF
var symbol = qb.AddEquity("SPY").Symbol;

// Add ETF Universe Selection
IEnumerable&lt;Symbol&gt; ETFConstituentsFilter(IEnumerable&lt;ETFConstituentUniverse&gt; constituents)
{
    // Take the top 10 weighted constituents
    return constituents
        .OrderByDescending(c =&gt; c.Weight)
        .Take(10)
        .Select(c =&gt; c.Symbol);
}

var universe = qb.AddUniverse(qb.Universe.ETF(spy, qb.UniverseSettings, ETFConstituentsFilter)); 

// Historical Universe data
var universeHistory = qb.UniverseHistory(universe, qb.Time.AddDays(-30), qb.Time);
foreach (var constituents in universeHistory )
{
    foreach (ETFConstituentUniverse constituent in constituents)
    {
        Console.WriteLine($"{constituent.Symbol} weight at {constituent.EndTime}: {constituent.Weight}");
    }
}</pre>
     <pre class="python">qb = QuantBook()

# Add the ETF
qb.spy = qb.add_equity("SPY").symbol

# Add ETF Universe Selection
def etf_constituents_filter(constituents):
    # Take the top 10 weighted constituents
    selected = sorted([c for c in constituents if c.weight],
        key=lambda c: c.weight, reverse=True)[:10]
    return [c.symbol for c in selected]

universe = qb.add_universe(qb.universe.etf(qb.spy, qb.universe_settings, etf_constituents_filter))

# Historical Universe data
universe_history = qb.universe_history(universe, qb.time-timedelta(30), qb.time)
for (universe_symbol, time), constituents in universe_history.items():
    for constituent in constituents:
        print(f"{constituent.symbol} weight at {constituent.end_time}: {constituent.weight}")</pre>
</div>