<p>
The Binance Crypto Future Margin Rate dataset enables correct margin cost so you can accurately design strategies for Cryptocurrencies with term structure. Examples include the following strategies:
</p>
<ul><li>Horizontal/Diagonal arbitrage with the underlying cryptocurrencies</li>
<li>Trade Contango/Backwardation predictions</li>
<li>Hedge for illiquid cryptocurrencies</li>
</ul>
<h4>Classic Algorithm Example</h4>
<p>The following example algorithm holds a long position in the BTCUSDT perpetual Future contract on the Binance exchange. When the margin interest rate is relatively low, it flips to a short position.</p>

<div class="section-example-container testable">
<pre class="python">from AlgorithmImports import *


class BinanceCryptoFutureDataAlgorithm(QCAlgorithm):

    # Add an indicator to track the low of trailing margin interest rates.
    _low_interest_rate = Minimum(10)

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        # Set Account Currency to USDT, since USD cannot be used to trade.
        self.set_cash("USDT", 100_000)
        # Binance Futures Exchange accepts both Cash and Margin account types, select the one you need for the best reality modeling.
        self.set_brokerage_model(BrokerageName.BINANCE_FUTURES, AccountType.MARGIN)
        # Requesting data, we only trade on BTCUSDT Future in Binance Future exchange
        # Perpetual futures does not have a filter function.
        self._future = self.add_crypto_future("BTCUSDT", Resolution.DAILY)
        # Historical data
        history = self.history[MarginInterestRate](self._future.symbol, 10, Resolution.DAILY)
        for data_point in history:
            self._low_interest_rate.update(data_point.end_time, data_point.interest_rate)

    def on_data(self, slice: Slice) -&gt; None:
        # Note that you may want to access the margin interest of the crypto future to calculate if it would impact a trade's PnL
        # Or you can calculate the trade size on keeping the quote currency constant
        if self._future.symbol not in slice.margin_interest_rates:
            return
        interest_rate = slice.margin_interest_rates[self._future.symbol].interest_rate
        self.plot('Margin Interest Rate', str(self._future.symbol), interest_rate)
        # Short when margin interest rates are relatively low. Otherwise, long.
        if interest_rate &lt;= self._low_interest_rate.current.value:
            if not self._future.holdings.is_short:
                self.set_holdings(self._future.symbol, -0.5)
        elif not self._future.holdings.is_long:
            self.set_holdings(self._future.symbol, 1)
        # Update the indicator.
        self._low_interest_rate.update(self.time, interest_rate)</pre>
<pre class="csharp">public class BinanceCryptoFutureDataAlgorithm : QCAlgorithm
{
    private CryptoFuture _future;
    // Add an indicator to track the low of trailing margin interest rates.
    private Minimum _lowInterestRate = new(10);

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        // Set Account Currency to USDT, since USD cannot be used to trade.
        SetCash("USDT", 100000);
        // Binance Futures Exchange accepts both Cash and Margin account types, select the one you need for the best reality modeling.
        SetBrokerageModel(BrokerageName.BinanceFutures, AccountType.Margin);
        // Requesting data, we only trade on BTCUSDT Future in Binance Future exchange
        // Perpetual futures does not have a filter function.
        _future = AddCryptoFuture("BTCUSDT", Resolution.Daily);
        // Historical data
        var history = History&lt;MarginInterestRate&gt;(_future.Symbol, 10, Resolution.Daily);
        foreach (var dataPoint in history)
        {
            _lowInterestRate.Update(dataPoint.EndTime, dataPoint.InterestRate);
        }
    }

    public override void OnData(Slice slice)
    {
        // Note that you may want to access the margin interest of the crypto future to calculate if it would impact a trade's PnL
        // Or you can calculate the trade size on keeping the quote currency constant
        if (!slice.MarginInterestRates.TryGetValue(_future.Symbol, out var dataPoint))
        {
            return;
        }
        var interestRate = dataPoint.InterestRate;
        Plot("Margin Interest Rate", _future.Symbol.ToString(), interestRate);
        // Short when margin interest rates are relatively low. Otherwise, long.
        if (interestRate &lt;= _lowInterestRate)
        {
            if (!_future.Holdings.IsShort)
            {
                SetHoldings(_future.Symbol, -0.5);
            }
        }
        else if (!_future.Holdings.IsLong)
        {
            SetHoldings(_future.Symbol, 1);
        }
        // Update the indicator.
        _lowInterestRate.Update(Time, interestRate);
    }
}</pre>
</div>
<h4>Framework Algorithm Example</h4>
<p>The following example algorithm holds a long position in the BTCUSDT perpetual Future contract on the Binance exchange. When the margin interest rate is relatively low, it flips to a short position.</p>

<div class="section-example-container testable">
<pre class="python">from AlgorithmImports import *


class BinanceCryptoFutureDataAlgorithm(QCAlgorithm):

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        self.settings.free_portfolio_value_percentage = 0.1
        # Set Account Currency to USDT, since USD cannot be used to trade.
        self.set_cash("USDT", 100000)
        # Binance Futures Exchange accepts both Cash and Margin account types, select the one you need for the best reality modeling.
        self.set_brokerage_model(BrokerageName.BINANCE_FUTURES, AccountType.MARGIN)

        self.universe_settings.resolution = Resolution.DAILY
        self.universe_settings.leverage = 2
        # We only trade on BTCUSDT Future in Binance Future exchange
        symbols = Symbol.create("BTCUSDT", SecurityType.CRYPTO_FUTURE, Market.BINANCE)
        self.add_universe_selection(ManualUniverseSelectionModel(symbols))
        # Custom alpha model to emit insights based on the Crypto Future price data
        self.add_alpha(CryptoFutureAlphaModel())
        # Equally invest to evenly dissipate the capital concentration risk of inidividual crypto pair
        self.set_portfolio_construction(EqualWeightingPortfolioConstructionModel())
        self.set_execution(ImmediateExecutionModel())


class CryptoFutureAlphaModel(AlphaModel):

    _min_by_symbol = {}

    def update(self, algorithm: QCAlgorithm, slice: Slice) -&gt; List[Insight]:
        insights = []
        for symbol, low_interest_rate in self._min_by_symbol.items():
            # Note that you may want to access the margin interest of the crypto future to calculate if it would impact a trade's PnL
            # Or you can calculate the trade size on keeping the quote currency constant
            if symbol not in slice.margin_interest_rates:
                continue
            interest_rate = slice.margin_interest_rates[symbol].interest_rate
            algorithm.plot('Margin Interest Rate', str(symbol), interest_rate)
            # Short when margin interest rates are relatively low. Otherwise, long.
            if interest_rate &lt;= low_interest_rate.current.value:
                direction = InsightDirection.DOWN
            else:
                direction = InsightDirection.UP
            insights.append(Insight.price(symbol, timedelta(1), direction))
            # Update the indicator.
            low_interest_rate.update(slice.time, interest_rate)
        return insights

    def on_securities_changed(self, algorithm: QCAlgorithm, changes: SecurityChanges) -&gt; None:
        for security in changes.added_securities:
            symbol = security.symbol
            # Add an indicator to track the low of trailing margin interest rates.
            self._min_by_symbol[symbol] = Minimum(10)
            # Historical data
            history = algorithm.history[MarginInterestRate](symbol, 10, Resolution.DAILY)
            for data_point in history:
                self._min_by_symbol[symbol].update(data_point.end_time, data_point.interest_rate)
        for security in changes.removed_securities:
            self._min_by_symbol.pop(security.symbol, None)</pre>
<pre class="csharp">public class BinanceCryptoFutureDataAlgorithm : QCAlgorithm
{
    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        Settings.FreePortfolioValuePercentage = 0.1m;
        // Set Account Currency to USDT, since USD cannot be used to trade.
        SetCash("USDT", 100000);
        // Binance Futures Exchange accepts both Cash and Margin account types, select the one you need for the best reality modeling.
        SetBrokerageModel(BrokerageName.BinanceFutures, AccountType.Margin);

        UniverseSettings.Resolution = Resolution.Daily;
        UniverseSettings.Leverage = 2;
        // We only trade on BTCUSDT Future in Binance Future exchange
        var symbols = new List&lt;Symbol&gt;{
            QuantConnect.Symbol.Create("BTCUSDT", SecurityType.CryptoFuture, Market.Binance)
        };
        AddUniverseSelection(new ManualUniverseSelectionModel(symbols));
        // Custom alpha model to emit insights based on the Crypto Future price data
        AddAlpha(new CryptoFutureAlphaModel());
        // Equally invest to evenly dissipate the capital concentration risk of inidividual crypto pair
        SetPortfolioConstruction(new EqualWeightingPortfolioConstructionModel());
        SetExecution(new ImmediateExecutionModel());
    }
}

public class CryptoFutureAlphaModel : AlphaModel
{
    private Dictionary&lt;Symbol, Minimum&gt; _minBySymbol = new();

    public override IEnumerable&lt;Insight&gt; Update(QCAlgorithm algorithm, Slice slice)
    {
        var insights = new List&lt;Insight&gt;();
        foreach (var kvp in _minBySymbol)
        {
            var symbol = kvp.Key;
            var lowInterestRate = kvp.Value;
            // Note that you may want to access the margin interest of the crypto future to calculate if it would impact a trade's PnL
            // Or you can calculate the trade size on keeping the quote currency constant
            if (!slice.MarginInterestRates.TryGetValue(symbol, out var dataPoint))
                continue;
            var interestRate = dataPoint.InterestRate;
            algorithm.Plot("Margin Interest Rate", symbol.ToString(), interestRate);
            // Short when margin interest rates are relatively low. Otherwise, long.
            var direction = interestRate &lt;= lowInterestRate.Current.Value
                ? InsightDirection.Down
                : InsightDirection.Up;
            insights.Add(Insight.Price(symbol, TimeSpan.FromDays(1), direction));
            // Update the indicator.
            lowInterestRate.Update(slice.Time, interestRate);
        }
        return insights;
    }

    public override void OnSecuritiesChanged(QCAlgorithm algorithm, SecurityChanges changes)
    {
        foreach (var security in changes.AddedSecurities)
        {
            var symbol = security.Symbol;
            // Add an indicator to track the low of trailing margin interest rates.
            var min = new Minimum(10);
            _minBySymbol[symbol] = min;
            // Historical data
            var history = algorithm.History&lt;MarginInterestRate&gt;(symbol, 10, Resolution.Daily);
            foreach (var dataPoint in history)
            {
                min.Update(dataPoint.EndTime, dataPoint.InterestRate);
            }
        }
        foreach (var security in changes.RemovedSecurities)
        {
            _minBySymbol.Remove(security.Symbol);
        }
    }
}</pre>
</div>