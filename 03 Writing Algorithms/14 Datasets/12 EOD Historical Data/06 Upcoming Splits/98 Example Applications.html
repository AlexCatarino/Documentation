
<
p
>


T
h
e
 
U
p
c
o
m
i
n
g
 
S
p
l
i
t
s
 
d
a
t
a
s
e
t
 
p
r
o
v
i
d
e
s
 
t
i
m
e
l
y
 
n
o
t
i
f
i
c
a
t
i
o
n
s
 
a
b
o
u
t
 
u
p
c
o
m
i
n
g
 
s
h
a
r
e
 
s
p
l
i
t
 
o
r
 
r
e
v
e
r
s
e
 
s
p
l
i
t
 
e
v
e
n
t
s
,
 
a
l
l
o
w
i
n
g
 
t
r
a
d
e
r
s
 
t
o
 
c
a
p
i
t
a
l
i
z
e
 
o
n
 
p
o
t
e
n
t
i
a
l
 
p
r
i
c
e
 
m
o
v
e
m
e
n
t
s
 
a
n
d
 
m
a
n
a
g
e
 
r
i
s
k
s
 
e
f
f
e
c
t
i
v
e
l
y
.
 
E
x
a
m
p
l
e
s
 
i
n
c
l
u
d
e
 
t
h
e
 
f
o
l
l
o
w
i
n
g
 
s
t
r
a
t
e
g
i
e
s
:
 


<
/
p
>




<
u
l
>
<
l
i
>
S
p
l
i
t
s
 
i
n
t
o
 
s
h
a
r
e
s
 
w
i
t
h
 
l
o
w
e
r
 
p
r
i
c
e
 
w
i
l
l
 
p
r
o
v
i
d
e
 
h
i
g
h
e
r
 
l
i
q
u
i
d
i
t
y
 
f
o
r
 
m
a
r
k
e
t
 
m
a
k
i
n
g
 
a
l
g
o
r
i
t
h
m
s
.
<
/
l
i
>


<
l
i
>
S
e
l
e
c
t
 
a
 
u
n
i
v
e
r
s
e
 
o
f
 
s
t
o
c
k
s
 
w
i
t
h
 
u
p
c
o
m
i
n
g
 
s
p
l
i
t
s
 
e
v
e
n
t
 
a
n
d
 
t
r
a
d
e
 
t
h
e
i
r
 
v
o
l
a
t
i
l
i
t
y
 
u
s
i
n
g
 
o
p
t
i
o
n
s
.
<
/
l
i
>


<
l
i
>
B
u
y
 
s
t
o
c
k
s
 
w
i
t
h
 
s
p
l
i
t
 
f
a
c
t
o
r
 
h
i
g
h
e
r
 
t
h
a
n
 
1
,
 
s
e
l
l
 
v
i
c
e
 
v
e
r
s
a
 
f
o
r
 
s
e
l
f
-
d
e
f
e
a
t
i
n
g
 
o
n
e
s
.
<
/
l
i
>


<
/
u
l
>
<h4>Classic Algorithm Example</h4><p>The following example algorithm holds each equity in equal size with upcoming splits within 7 days. It selects stocks that split up to more shares with lower price and tries to capitalize the higher demand of the more afforable stocks.</p>

<div class="section-example-container">
<pre class="python">class UpcomingSplitsExampleAlgorithm(QCAlgorithm):
    def initialize(self) -&gt; None:
        self.set_start_date(2020, 1, 1)
        self.set_end_date(2024, 10, 1)
        self.set_cash(100000)

        # Trade on daily basis based on daily upcoming splits signals.
        self.universe_settings.resolution = Resolution.DAILY
        # Universe consists of equities with upcoming splits events.
        self._universe = self.add_universe(EODHDUpcomingSplits, self.selection)
    
    def selection(self, splits: List[EODHDUpcomingSplits]) -&gt; List[Symbol]:
        # Split (more shares with lower price) will make the stock more affordable and drive up the demand.
        # Hence, include all stocks that will have a split within the next 7 days.
        # Note that spliting up the stock means the split factor &gt; 1.
        return [x.symbol for x in splits if x.split_factor &gt; 1]
    
    def on_data(self, slice: Slice) -&gt; None:
        # Equally invest in each member of the universe to evenly dissipate the capital risk.
        total_count = len(self._universe.members)
        targets = [PortfolioTarget.percent(self, symbol, 1. / total_count) for symbol in self._universe.members.keys()]
        self.set_holdings(targets)

    def on_securities_changed(self, changes: SecurityChanges) -&gt; None:
        for removed in changes.removed_securities:
            # Liquidate the ones exit the universe (already split) to capitalize the microeconomic demand.
            self.liquidate(removed.symbol)</pre>
<pre class="csharp">namespace QuantConnect
{
    public class UpcomingSplitsExampleAlgorithm : QCAlgorithm
    {
        private Universe _universe;

        public override void Initialize()
        {
            SetStartDate(2020, 1, 1);
            SetEndDate(2024, 10, 1);
            SetCash(100000);

            // Trade on daily basis based on daily upcoming earnings signals.
            UniverseSettings.Resolution = Resolution.Daily;
            // Universe consists of equities with upcoming earnings events.
            _universe = AddUniverse&lt;EODHDUpcomingSplits&gt;((splits) =&gt; {
                return splits
                    // Split (more shares with lower price) will make the stock more affordable and drive up the demand.
                    // Hence, include all stocks that will have a split within the next 7 days.
                    // Note that spliting up the stock means the split factor &gt; 1.
                    .Where(datum =&gt; (datum as EODHDUpcomingSplits).SplitFactor &gt; 1)
                    .Select(datum =&gt; datum.Symbol);
            });
        }

        public override void OnData(Slice slice)
        {
            // Equally invest in each member of the universe to evenly dissipate the capital risk.
            var totalCount = _universe.Members.Count;
            var targets = _universe.Members.Keys
                .Select(symbol =&gt; (PortfolioTarget)PortfolioTarget.Percent(this, symbol, 1m / totalCount))
                .ToList();
            SetHoldings(targets);
        }

        public override void OnSecuritiesChanged(SecurityChanges changes)
        {
            foreach (var removed in changes.RemovedSecurities)
            {
                // Liquidate the ones exit the universe (already split) to capitalize the microeconomic demand.
                Liquidate(removed.Symbol);
            }
        }
    }
}</pre>
</div><h4>Framework Algorithm Example</h4><p>The following example algorithm holds each equity in equal size with upcoming splits within 7 days using algorithm framework. It selects stocks that split up to more shares with lower price and tries to capitalize the higher demand of the more afforable stocks.</p>

<div class="section-example-container">
<pre class="python">class UpcomingSplitsExampleAlgorithm(QCAlgorithm):
    def initialize(self) -&gt; None:
        self.set_start_date(2020, 1, 1)
        self.set_end_date(2024, 10, 1)
        self.set_cash(100000)

        # Trade on daily basis based on daily upcoming splits signals.
        self.universe_settings.resolution = Resolution.DAILY
        # Universe consists of equities with upcoming splits events.
        self._universe = self.add_universe(EODHDUpcomingSplits, self.selection)

        # Constant alpha model to emit insights for the stocks with split up event within a week, estimating their demand and price will go up.
        # Signal stays for 2 days to fully digest the driven up demands.
        self.add_alpha(ConstantAlphaModel(InsightType.PRICE, InsightDirection.UP, timedelta(2)))

        # Equal weighting for each signal to evenly dissipate the capital risk.
        self.set_portfolio_construction(EqualWeightingPortfolioConstructionModel(Expiry.END_OF_DAY))
    
    def selection(self, splits: List[EODHDUpcomingSplits]) -&gt; List[Symbol]:
        # Split (more shares with lower price) will make the stock more affordable and drive up the demand.
        # Hence, include all stocks that will have a split within the next 7 days.
        # Note that spliting up the stock means the split factor &gt; 1.
        return [x.symbol for x in splits if x.split_factor &gt; 1]</pre>
<pre class="csharp">namespace QuantConnect
{
    public class UpcomingSplitsExampleAlgorithm : QCAlgorithm
    {
        private Universe _universe;

        public override void Initialize()
        {
            SetStartDate(2020, 1, 1);
            SetEndDate(2024, 10, 1);
            SetCash(100000);

            // Trade on daily basis based on daily upcoming splits signals.
            UniverseSettings.Resolution = Resolution.Daily;
            // Universe consists of equities with upcoming splits events.
            _universe = AddUniverse&lt;EODHDUpcomingSplits&gt;((splits) =&gt; {
                return splits
                    // Split (more shares with lower price) will make the stock more affordable and drive up the demand.
                    // Hence, include all stocks that will have a split within the next 7 days.
                    // Note that spliting up the stock means the split factor &gt; 1.
                    .Where(datum =&gt; (datum as EODHDUpcomingSplits).SplitFactor &gt; 1)
                    .Select(datum =&gt; datum.Symbol);
            });

            // Constant alpha model to emit insights for the stocks with split up event within a week, estimating their demand and price will go up.
            // Signal stays for 2 days to fully digest the driven up demands.
            AddAlpha(new ConstantAlphaModel(InsightType.Price, InsightDirection.Up, TimeSpan.FromDays(2)));

            // Equal weighting for each signal to evenly dissipate the capital risk.
            SetPortfolioConstruction(new EqualWeightingPortfolioConstructionModel(Expiry.EndOfDay));
        }
    }
}</pre>
</div>