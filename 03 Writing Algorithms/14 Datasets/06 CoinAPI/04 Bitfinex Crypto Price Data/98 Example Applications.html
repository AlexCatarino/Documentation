<p>
The Bitfinex Crypto Price dataset enables you to accurately design strategies for Cryptocurrencies. Examples include the following strategies:
</p>
<ul><li>Buy and hold</li>
<li>Trading Cryptocurrency volatility and price action</li>
<li>Allocating a small portion of your portfolio to Cryptocurrencies to hedge against inflation</li>
</ul>
<h4>Classic Algorithm Example</h4>
<p>The following example algorithm buys and holds Bitcoin through the Bitfinex exchange:</p>

<div class="section-example-container testable">
<pre class="python">from AlgorithmImports import *


class CoinAPIDataAlgorithm(QCAlgorithm):

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        self.universe_settings.asynchronous = True
        self.set_cash(100_000)
        # Bitfinex accepts both Cash and Margin account types. Select the
        # one you need for the best reality modeling.
        self.set_brokerage_model(BrokerageName.BITFINEX, AccountType.MARGIN)
        # Add BTCUSD data.
        self._btc = self.add_crypto("BTCUSD", Resolution.MINUTE, Market.BITFINEX)
        # Historical data
        history = self.history(self._btc.symbol, 30, Resolution.DAILY)
        # Add a Crypto universe that selects Crypto pairs on Bitfinex.
        universe = self.add_universe(CryptoUniverse.bitfinex(self._select_assets))
        # Historical Universe data
        universe_history = self.history(universe, 30, Resolution.DAILY)
        for (universe_symbol, time), universe_day in universe_history.items():
            for universe_item in universe_day:
                symbol = universe_item.symbol
                price = universe_item.close

    def _select_assets(self, universe_day):
        # Filter for materially traded Crypto pairs with significant 
        # size and dollar volume, assuming higher capital flow in for 
        # higher return.
        return [universe_item.symbol for universe_item in universe_day
                if universe_item.volume &gt;= 100 
                and universe_item.volume_in_usd &gt; 10_000_000]

    def on_data(self, slice: Slice) -&gt; None:
        # Speculate-invest all available free cash on BTCUSD, repecting 
        # the order quantity restrictions to avoid invalid orders.
        if self.portfolio.cash_book['BTC'].amount != 0:
            return
        # Define a buffer so that we can scale down the order size,
        # avoiding trading errors.
        buffer = max(
            BitfinexFeeModel.TAKER_FEE, 
            self.settings.free_portfolio_value_percentage
        )
        quantity = (
            self.portfolio.cash_book['USD'].amount
            / self._btc.ask_price
            * (1-buffer)
        )
        # Check if the quantity exceeds the minimum order size. On 
        # Bitfinex, the minimum order size is measured in the base
        # currency (BTC in this case).
        if abs(quantity) &lt; self._btc.symbol_properties.minimum_order_size:
            return
        self.market_order(self._btc, quantity)</pre>
<pre class="csharp">public class CoinAPIDataAlgorithm : QCAlgorithm
{
    private Crypto _btc;
    
    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        UniverseSettings.Asynchronous = true;
        SetCash(100000);
        // Bitfinex accepts both Cash and Margin account types. Select the
        // one you need for the best reality modeling.
        SetBrokerageModel(BrokerageName.Bitfinex, AccountType.Margin);
        // Add BTCUSD data.
        _btc = AddCrypto("BTCUSD", Resolution.Minute, Market.Bitfinex);   
        // Historical data
        var history = History(_btc.Symbol, 30, Resolution.Daily);
        // Add a Crypto universe that selects trading pairs on Bitfinex.
        var universe = AddUniverse(CryptoUniverse.Bitfinex(SelectAssets));
        // Historical Universe data
        var universeHistory = History(universe, 30, Resolution.Daily);
        foreach (var universeDay in universeHistory)
        {
            foreach (CryptoUniverse universeItem in universeDay)
            {
                var symbol = universeItem.Symbol;
                var price = universeItem.Close;
            }
        }
    }

    private IEnumerable&lt;Symbol&gt; SelectAssets(IEnumerable&lt;CryptoUniverse&gt; universeDay)
    {
        // Filter for materially traded Crypto pairs with significant 
        // size and dollar volume, assuming higher capital flow in for 
        // higher return.
        return from universeItem in universeDay
                where universeItem.Volume &gt;= 100m 
                &amp;&amp; universeItem.VolumeInUsd &gt; 10000000m
                select universeItem.Symbol;
    }

    public override void OnData(Slice slice)
    {
        // Speculate-invest all available free cash on BTCUSD, repecting 
        // the order quantity restrictions to avoid invalid orders.
        if (Portfolio.CashBook["BTC"].Amount != 0)
        {
            return;
        }
        // Define a buffer so that we can scale down the order size,
        // avoiding trading errors.
        var buffer = Math.Max(BitfinexFeeModel.TakerFee, Settings.FreePortfolioValuePercentage);
        var quantity = Portfolio.CashBook["USD"].Amount / _btc.AskPrice * (1-buffer);
        // Check if the quantity exceeds the minimum order size. On 
        // Bitfinex, the minimum order size is measured in the base
        // currency (BTC in this case).
        if (Math.Abs(quantity) &lt; _btc.SymbolProperties.MinimumOrderSize)
        {
            return;
        }
        MarketOrder(_btc, quantity);
    }
}</pre>
</div>
<h4>Framework Algorithm Example</h4>
<p>The following example algorithm creates a dynamic universe of Crypto pairs on the Bitfinex exchange and then forms a equal-weighted portfolio of all the pairs in the universe:</p>

<div class="section-example-container testable">
<pre class="python">from AlgorithmImports import *


class CoinAPIDataAlgorithm(QCAlgorithm):

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        self.set_cash(100000)
        self.settings.free_portfolio_value_percentage = 0.05
        # Bitfinex accepts both Cash and Margin account types, select the one you need for the best reality modeling.
        self.set_brokerage_model(BrokerageName.BITFINEX, AccountType.MARGIN)

        # Warm up the security with the last known price to avoid conversion error
        self.set_security_initializer(lambda security: security.set_market_price(self.get_last_known_price(security)))
        self.universe_settings.asynchronous = True
        self.universe_settings.resolution = Resolution.MINUTE
        # Add Crypto Universe Selection that select crypto pairs in Bitfinex exchange
        self.add_universe(CryptoUniverse.bitfinex(self._select_assets))
        # Get the pairs on Bitfinex that have USD as the quote currency.
        self._market_pairs = [
            x.key.symbol 
            for x in self.symbol_properties_database.get_symbol_properties_list(Market.BITFINEX) 
            if x.value.quote_currency == self.account_currency
        ]
        self.add_alpha(ConstantAlphaModel(InsightType.PRICE, InsightDirection.UP, timedelta(hours=4), 0.025, None))
        # Equally invest to evenly dissipate the capital concentration risk of inidividual crypto pair
        self.set_portfolio_construction(EqualWeightingPortfolioConstructionModel())

    def _select_assets(self, universe_day: List[CryptoUniverse]) -&gt; List[Symbol]:
        # Select pairs where the quote currency is USD.
        pairs = [c for c in universe_day if c.symbol.value in self._market_pairs]
        # Filter for materially traded crypto pairs with significant dollar volume, assuming higher capital flow in for higher return.
        pairs = sorted(pairs, key=lambda c: c.volume_in_usd)[-3:]      
        return [c.symbol for c in pairs]

    def on_securities_changed(self, changes: SecurityChanges) -&gt; None:
        for security in changes.added_securities:
            # Historical data
            history = self.history(security.symbol, 30, Resolution.DAILY)
            self.debug(f"We got {len(history)} items from our history request")</pre>
<pre class="csharp">public class CoinAPIDataAlgorithm : QCAlgorithm
{
    private List&lt;string&gt; _marketPairs;
    
    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        SetCash(100000);
        Settings.FreePortfolioValuePercentage = 0.05m;
        // Bitfinex accepts both Cash and Margin account types, select the one you need for the best reality modeling.
        SetBrokerageModel(BrokerageName.Bitfinex, AccountType.Margin);

        // Warm up the security with the last known price to avoid conversion error
        SetSecurityInitializer(security =&gt; security.SetMarketPrice(GetLastKnownPrice(security)));
        UniverseSettings.Asynchronous = true;
        UniverseSettings.Resolution = Resolution.Minute;
        // Add Crypto Universe Selection that select crypto pairs in Bitfinex exchange            
        AddUniverse(CryptoUniverse.Bitfinex(SelectAssets));
        // Get the pairs on Bitfinex that have USD as the quote currency.
        _marketPairs = SymbolPropertiesDatabase.GetSymbolPropertiesList(Market.Bitfinex)
            .Where(x =&gt; x.Value.QuoteCurrency == AccountCurrency)
            .Select(x =&gt; x.Key.Symbol)
            .ToList();
        AddAlpha( new ConstantAlphaModel(InsightType.Price, InsightDirection.Up, TimeSpan.FromHours(4), 0.025, null) );
        // Equally invest to evenly dissipate the capital concentration risk of inidividual crypto pair
        SetPortfolioConstruction(new EqualWeightingPortfolioConstructionModel());
    }

    private IEnumerable&lt;Symbol&gt; SelectAssets(IEnumerable&lt;CryptoUniverse&gt; universeDay)
    {
        // Select pairs where the quote currency is USD.
        return universeDay.Where(c =&gt; _marketPairs.Contains(c.Symbol.Value))
            // Filter for materially traded crypto pairs with significant size and dollar volume, assuming higher capital flow in for higher return
            .OrderBy(c =&gt; c.VolumeInUsd)
            .TakeLast(3)
            .Select(c =&gt; c.Symbol);
    }

    public override void OnSecuritiesChanged(SecurityChanges changes)
    {
        foreach(var security in changes.AddedSecurities)
        {
            // Historical data
            var history = History(security.Symbol, 30, Resolution.Daily);
            Debug($"We got {history.Count()} items from our history request");
        }
    }
}</pre>
</div>
<h4>Research  Example</h4>
<p>The following example lists crypto-currency pairs with the greatest dollar volume in the Bitfinex exchange:</p>

<div class="section-example-container">
        <pre class="csharp">var qb = new QuantBook();

// Add Cryptocurrency pair
var symbol = qb.AddCrypto("BTCUSDT", market:Market.Bitfinex).Symbol;

// Historical data
var history = qb.History(symbol, 30, Resolution.Daily);
foreach (var bar in history)
{
    Console.WriteLine($"{bar.EndTime} {bar}");
}

// Add Crypto Universe Selection
IEnumerable&lt;Symbol&gt; UniverseSelectionFilter(IEnumerable&lt;CryptoUniverse&gt; universeDay)
{
    return universeDay
        .Where(x =&gt; x.VolumeInUsd != null &amp;&amp; x.VolumeInUsd &gt; 10000m)
        .OrderByDescending(x =&gt; x.VolumeInUsd)
        .Take(5)
        .Select(x =&gt; x.Symbol);
}
var universe = qb.AddUniverse(CryptoUniverse.Bitfinex(UniverseSelectionFilter));

// Historical Universe data
var universeHistory = qb.UniverseHistory(universe, qb.Time.AddDays(-30), qb.Time);
foreach (var universeDay in universeHistory)
{
    Console.WriteLine($"=== {universeDay.First().EndTime} ===");
    foreach (CryptoUniverse universeItem in universeDay.OrderByDescending(x =&gt; x.VolumeInUsd))
    {
        Console.WriteLine($"{universeItem.Symbol}: {universeItem.VolumeInUsd}");
    }
}</pre>
     <pre class="python">qb = QuantBook()

# Add Cryptocurrency pair
symbol = qb.add_crypto("BTCUSDT", market=Market.BITFINEX).symbol

# Historical data
history = qb.history(symbol, 30, Resolution.DAILY)
for (symbol, time), row in history.iterrows():
    print(f'{time} {symbol} {row.close}')

# Add Crypto Universe Selection
def universe_selection_filter(universe_day):
    selected = sorted([x for x in universe_day
        if x.volume_in_usd and x.volume_in_usd &gt; 10000],
        key=lambda x: x.volume_in_usd, reverse=True)[:5]
    return [x.symbol for x in selected]

universe = qb.add_universe(CryptoUniverse.bitfinex(universe_selection_filter))

# Historical Universe data
history = qb.universe_history(universe, qb.time-timedelta(30), qb.time)
for (univere_symbol, time), universe_day in history.items():
    print(f'=== {time} ===')
    for universe_item in sorted(universe_day, key=lambda x: x.volume_in_usd, reverse=True):
        print(f"{universe_item.symbol}: {universe_item.volume_in_usd}")</pre>
</div>