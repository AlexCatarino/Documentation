<p>
Execution models have one required method to implement <code>Execute(algorithm, targets)</code>. This is responsible for reaching the target portfolios as efficiently as possible. The <code>PortfolioTarget</code> objects are created by the <a href="/docs/algorithm-framework/portfolio-construction" class="docs-internal-link">Portfolio Construction Model</a> and then adjusted by the <a href="/docs/algorithm-framework/risk-management" class="docs-internal-link">Risk Management Module</a>. The final risk adjusted portfolio targets are delivered to your execution model for fulfillment.
</p>
<div class="section-example-container">
	<pre class="csharp"> // Basic Execution Model Scaffolding Structure Example
class MyExecutionModel : ExecutionModel {

   // Fill the supplied portfolio targets efficiently. 
   public override void Execute(QCAlgorithmFramework algorithm, IPortfolioTarget[] targets)
   {
      // NOP
   }

   //  Optional: Securities changes event for handling new securities.
   public override void OnSecuritiesChanged(QCAlgorithmFramework algorithm, 
                                            SecurityChanges changes)
   {
   }
}</pre>
	<pre class="python">
from clr import AddReference
AddReference("QuantConnect.Algorithm.Framework")
from QuantConnect.Algorithm.Framework.Execution import ExecutionModel

# Execution Model scaffolding structure example
class MyExecutionModel(ExecutionModel):
    
    # Fill the supplied portfolio targets efficiently
    def Execute(self, algorithm, targets):
        pass

    # Optional: Securities changes event for handling new securities.
    def OnSecuritiesChanged(self, algorithm, changes):
        pass</pre>
</div>.