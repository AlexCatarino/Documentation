<p>
算法框架内置于QCAlgorithm类中，因此您的策略可以访问所有用于算法开发的常规方法。<b>不需要额外的类。</b>
</p>
<figure><img src="https://cdn.quantconnect.com/web/i/docs/algorithm-framework/class-structure_rev2.png" class="img-responsive">
	<figcaption>算法框架类的层次结构</figcaption>
</figure>
<p>每个模块的框架数据输出会流入下一个模块。由<i>资产集选择</i>选择的资产将流入您的<i>阿尔法</i>模型中以生成交易信号。交易信号(<i>Insights</i>)将通过<i>投资组合构建</i>模块转换为投资组合目标。投资组合目标将保存我们希望算法持有的股票数量目标。<i>执行</i>模块会随着时间的推移有效地实现这些目标。最后，<i>风险管理</i>模块会确保我们的目标仍在安全风险参数范围内，并在需要时调整投资组合目标。
</p>
<figure><img src="https://cdn.quantconnect.com/web/i/docs/algorithm-framework/algorithm-framework.png" class="img-responsive">
	<figcaption>
QuantConnect算法框架体系结构
</figcaption>
</figure>
<div class="section-example-container">
	<pre class="csharp">public class MyFrameworkAlgorithm : QCAlgorithm {
      public void Initialize() {
           // 设置您需要的模块
      }
}</pre>
	<pre class="python">class MyFrameworkAlgorithm(QCAlgorithm):
     def Initialize(self):
           # 设置您需要的模块 </pre>
</div>
<p>对于简单的策略来说，抽象出您的算法概念似乎有些多余。然而，即使是简单的策略也可以从QuantConnect可用模块的生态系统中受益。试想，将您的EMA-cross与更好地执行系统配对？或是插入开源的追踪止损风险管理模型？</p>
