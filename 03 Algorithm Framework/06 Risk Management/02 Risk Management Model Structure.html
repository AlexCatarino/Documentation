<p>
The Risk Management Model should extend the RiskManagementModel class and has one required method; <code>ManageRisk()</code> which receives an array of <code>PortfolioTarget</code> objects. When an adjustment of the targets is required you should return the <i>changed</i> targets only. Optionally you can also use the <code>OnSecuritiesChanged()</code> event.
</p>
<div class="section-example-container">
	<pre class="csharp">class MaximumDrawdownPerSecurity : RiskManagementModel 
{
    // Adjust the portfolio targets and return them. If no changes emit nothing.
    List&lt;PortfolioTarget&gt; ManageRisk(QCAlgorithmFramework algorithm, PortfolioTarget[] targets)      {
    }
 
    // Optional: Be notified when securities change
    void OnSecuritiesChanged(QCAlgorithmFramework algorithm, SecurityChanges changes)
    {
    }
}</pre>
	<pre class="python">class MaximumDrawdownPerSecurity(RiskManagementModel):
    # Adjust the portfolio targets and return them. If no changes emit nothing.
    def ManageRisk(self, algorithm, targets):
        return []

    # Optional: Be notified when securities change
    def OnSecuritiesChanged(self, algorithm, changes):
        pass
</pre>
</div>