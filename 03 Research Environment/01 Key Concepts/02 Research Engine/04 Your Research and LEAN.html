<p>To analyze data in a research notebook, create an instance of the <code>QuantBook</code> class. <code>QuantBook </code>is a wrapper on <code>QCAlgorithm</code>, which means <code>QuantBook </code>allows you to access all the methods available to <code>QCAlgorithm</code> and some additional methods. The following table describes the helper methods of the <code>QuantBook</code> class that aren't available in the <code>QCAlgorithm</code> class:</p>

<table class="qc-table table">
    <thead>
        <tr>
            <th>Method</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>GetFundamental</code></td>
            <td>Get fundamental data for some Symbol(s).</td>
        </tr>
        <tr>
            <td><code>GetFutureHistory</code></td>
            <td>Get the expiration, open interest, and price data of the contracts in a Futures chain.</td>
        </tr>
        <tr>
            <td><code>GetOptionHistory</code></td>
            <td>Get the strike, expiration, open interest, option right, and price data of the contracts in an Options chain.</td>
        </tr>
    </tbody>
</table>


<div class="section-example-container">
<pre class="csharp">public class QuantBook : QCAlgorithm
{
    public IEnumerable&lt;DataDictionary&lt;dynamic&gt;&gt; GetFundamental(
        Symbol symbol, string selector = null, 
        DateTime? start = null, DateTime? end = null) 
        { ... };

    public FutureHistory GetFutureHistory(
        Symbol symbol, DateTime start, DateTime? end = null, Resolution? resolution = null) 
        { ... };

    public OptionHistory GetOptionHistory(
        Symbol symbol, DateTime start, DateTime? end = null, Resolution? resolution = null) 
        { ... };
}</pre>
<pre class="python">class QCAlgorithm:
    def GetFundamental(self, symbol: Symbol, selector: string, start: datetime, end: datetime) -> pandas.DataFrame:

    def GetFutureHistory(self, symbol: Symbol, start: datetime, end: datetime, resolution: Resolution) -&gt; FutureHistory:

    def GetOptionHistory(self, symbol: Symbol, start: datetime, end: datetime, resolution: Resolution) -&gt; OptionHistory:</pre>
</div>


<p>QuantBook gives you access to the vast amounts of data in the Dataset Market. Similar to backtesting, you can access that data using history 
calls. You can also create indicators, consolidate data, and access 
charting features. However, keep in mind that event-driven features 
available in backtesting, like universe selection and OnData events, are
 not available in research. After you analyze a dataset in the Research Environment, you can easily transfer the logic to the backtesting environment. For most intents and purposes, to move logic from the Research Environment to the backtesting environment, replace <code>qb</code> with <code>self</code>. For example, consider the following code in the Research Environment:
</p>

<div class="section-example-container">
	<pre class="python"># Initialize QuantBook
qb = QuantBook()

# Subscribe to SPY data with QuantBook
spy = qb.AddEquity("SPY")

# Make history call with QuantBook
history = qb.History(spy.Symbol, timedelta(days=10), Resolution.Daily)
</pre>
</div>

<p>
To use the preceding code in a backtest, replace <code>qb = QuantBook()</code> with <code>qb = self</code>.
</p>

<div class="section-example-container">
	<pre class="python">def Initialize(self) -&gt; None:

    # Set qb to instance of QCAlgorithm
    qb = self
    
    # Subscribe to SPY data with QCAlgorithm
    spy = qb.AddEquity("SPY")
    
    # Make history call with QCAlgorithm
    history = qb.History(spy.Symbol, timedelta(days=10), Resolution.Daily)
</pre>
</div>
