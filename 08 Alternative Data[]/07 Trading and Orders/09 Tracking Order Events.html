<p>
Each order generates events over its life as the status changes. These events are passed to the <code>OnOrderEvent()</code> method which you can use for information about your order states. The event handler is passed an $[OrderEvent, T:QuantConnect.Orders.OrderEvent] object which has information about the order status.
</p>

<div class="section-example-container">
<pre class="csharp">public override void OnOrderEvent(OrderEvent orderEvent) {
    var order = Transactions.GetOrderById(orderEvent.OrderId);
    if (orderEvent.Status == OrderStatus.Filled) 
         Console.WriteLine("{0}: {1}: {2}", Time, order.Type, orderEvent);
}
</pre>
<pre class="python">def OnOrderEvent(self, orderEvent):
    order = self.Transactions.GetOrderById(orderEvent.OrderId)
    if orderEvent.Status == OrderStatus.Filled: 
        self.Log("{0}: {1}: {2}".format(self.Time, order.Type, orderEvent))
</pre>
</div>
<p>The $[OrderStatus, T:QuantConnect.Orders.OrderStatus] enum has the following potential values.</p>
<table class="qc-table table  table-condensed">
<thead>
<tr>
<th width="30%">Status</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr><td><code>OrderStatus.New</code></td><td><p>Order is created by has not been submitted by the brokerage.</p></td></tr>
<tr><td><code>OrderStatus.Submitted</code></td><td><p>Order has been successfully submitted to the brokerage.</p></td></tr>
<tr><td><code>OrderStatus.PartiallyFilled</code></td><td><p>Order has some of its requested quantity processed by brokerage.</p></td></tr>
<tr><td><code>OrderStatus.Filled</code></td><td><p>Order is completely filled by brokerage.</p></td></tr>
<tr><td><code>OrderStatus.Canceled</code></td><td><p>Order cancelled before it was filled.</p></td></tr>
<tr><td><code>OrderStatus.Invalid</code></td><td><p>Order <a href="/docs/alternative-data/trading-and-orders#Trading-and-Orders-Order-Error-Code-Reference">invalidated</a> before it was accepted by LEAN.</p></td></tr>
</tbody>
</table>

