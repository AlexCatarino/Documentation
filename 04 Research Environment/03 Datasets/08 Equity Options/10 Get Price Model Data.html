<p>Follow these steps to get the values of implied volatility, and Greeks:</p>

<ol>
    <li><a href="/docs/v2/research-environment/datasets/equity-options#03-Create-Subscriptions">Create subscriptions</a> of the underlying. Get and filter the option contracts.</li>
    <div class="section-example-container">
        <pre class="python">qb = QuantBook()

# Set price seeder to ensure underlying price ready for filtering
qb.set_security_initializer(lambda security: FuncSecuritySeeder(qb.get_last_known_prices).seed_security(security))
# Subscribe to the underlying Equity with raw data normalization.
underlying = qb.add_equity("SPY", data_normalization_mode=DataNormalizationMode.RAW).symbol
underlying_price = qb.securities[underlying].price

# Get the Option contracts that were tradable on August 28th, 2024.
qb.set_start_date(2024, 8, 28)
contract_list = qb.option_chain_provider.get_option_contract_list(underlying, qb.start_date)
expiry = min([x.id.date for x in contract_list])

# Select the call contracts that expire the earliest. 
contract_list = [s for s in contract_list if s.id.date == expiry]</pre>
        <pre class="csharp">var qb = new QuantBook();

// Set price seeder to ensure underlying price ready for filtering
qb.SetSecurityInitializer((security) =&gt; new FuncSecuritySeeder(qb.GetLastKnownPrices).SeedSecurity(security));
// Subscribe to the underlying Equity with raw data normalization.
var underlying = qb.AddEquity("SPY", dataNormalizationMode: DataNormalizationMode.Raw).Symbol;
var underlyingPrice = qb.Securities[underlying].Price;

// Get the Option contracts that were tradable on August 28th, 2024.
qb.SetStartDate(2024, 8, 28);
var contractList = qb.OptionChainProvider.GetOptionContractList(underlying, qb.StartDate);
var expiry = contractList.Min(x =&gt; x.ID.Date);

// Select the call contracts that expire the earliest. 
contractList = contractList.Where(s =&gt; s.ID.Date == expiry).ToList();</pre>
    </div>

    <li>Set up <a href="/docs/v2/writing-algorithms/securities/asset-classes/equity-options/greeks-and-implied-volatility/option-indicators">Implied Volatility & Greeks Indicators</a> for each contract selected.</li>
    <div class="section-example-container">
        <pre class="python"># Set up risk free rate, dividend yield, and option pricing model
risk_free_rate_model = qb.risk_free_interest_rate_model
dividend_yield_model = DividendYieldProvider(underlying)
option_model = OptionPricingModelType.FORWARD_TREE

# Define a method to generate the option indicator history
def get_indicators(contracts):
    # Mirror option contract pairs
    call, put = contracts
    if call.id.option_right == OptionRight.PUT:
        call, put = put, call

    def get_value(indicator):
        # Use both call and put contract with the underlying to obtain indicator history and update the indicator
        qb.indicator_history(indicator, [call, put, call.Underlying], 1)
        return indicator.current.value

    # Obtain values from all IV and Greeks indicators
    return {
        'iv_call': get_value(ImpliedVolatility(call, risk_free_rate_model, dividend_yield_model, put, option_model)),
        'iv_put': get_value(ImpliedVolatility(put, risk_free_rate_model, dividend_yield_model, call, option_model)),
        'delta_call': get_value(Delta(call, risk_free_rate_model, dividend_yield_model, put, option_model)),
        'delta_put': get_value(Delta(put, risk_free_rate_model, dividend_yield_model, call, option_model)),
        'gamma_call': get_value(Gamma(call, risk_free_rate_model, dividend_yield_model, put, option_model)),
        'gamma_put': get_value(Gamma(put, risk_free_rate_model, dividend_yield_model, call, option_model)),
        'rho_call': get_value(Rho(call, risk_free_rate_model, dividend_yield_model, put, option_model)),
        'rho_put': get_value(Rho(put, risk_free_rate_model, dividend_yield_model, call, option_model)),
        'vega_call': get_value(Vega(call, risk_free_rate_model, dividend_yield_model, put, option_model)),
        'vega_put': get_value(Vega(put, risk_free_rate_model, dividend_yield_model, call, option_model)),
        'theta_call': get_value(Theta(call, risk_free_rate_model, dividend_yield_model, put, option_model)),
        'theta_put': get_value(Theta(put, risk_free_rate_model, dividend_yield_model, call, option_model)),
    }</pre>
        <pre class="csharp">// Set up risk free rate, dividend yield, and option pricing model
var riskFreeRateModel = qb.RiskFreeInterestRateModel;
var dividendYieldModel = new DividendYieldProvider(underlying);
var optionModel = OptionPricingModelType.ForwardTree;

// Define a method to generate the option indicator history
(decimal IVCall, decimal IVPut,
decimal DeltaCall, decimal DeltaPut,
decimal GammaCall, decimal GammaPut,
decimal VegaCall, decimal VegaPut,
decimal ThetaCall, decimal ThetaPut,
decimal RhoCall, decimal RhoPut) GetIndicators(Symbol call, Symbol put)
{
    decimal GetValue(OptionIndicatorBase indicator)
    {
        // Use both call and put contract with the underlying to obtain indicator history and update the indicator
        qb.IndicatorHistory(indicator, new[] { call, put, underlying }, 1);
        return indicator.Current.Value;
    }

    // Obtain values from all IV and Greeks indicators
    return (
        IVCall: GetValue(new ImpliedVolatility(call, riskFreeRateModel, dividendYieldModel, put, optionModel)),
        IVPut: GetValue(new ImpliedVolatility(put, riskFreeRateModel, dividendYieldModel, call, optionModel)),
        DeltaCall: GetValue(new Delta(call, riskFreeRateModel, dividendYieldModel, put, optionModel)),
        DeltaPut: GetValue(new Delta(put, riskFreeRateModel, dividendYieldModel, call, optionModel)),
        GammaCall: GetValue(new Gamma(call, riskFreeRateModel, dividendYieldModel, put, optionModel)),
        GammaPut: GetValue(new Gamma(put, riskFreeRateModel, dividendYieldModel, call, optionModel)),
        VegaCall: GetValue(new Vega(call, riskFreeRateModel, dividendYieldModel, put, optionModel)),
        VegaPut: GetValue(new Vega(put, riskFreeRateModel, dividendYieldModel, call, optionModel)),
        ThetaCall: GetValue(new Theta(call, riskFreeRateModel, dividendYieldModel, put, optionModel)),
        ThetaPut: GetValue(new Theta(put, riskFreeRateModel, dividendYieldModel, call, optionModel)),
        RhoCall: GetValue(new Rho(call, riskFreeRateModel, dividendYieldModel, put, optionModel)),
        RhoPut: GetValue(new Rho(put, riskFreeRateModel, dividendYieldModel, call, optionModel))
    );
}</pre>
    </div>

    <li>Group contracts by strike price, then obtain the indicators' values.</li>
    <div class="section-example-container">
        <pre class="python">from itertools import groupby
keyfunc = lambda x: x.id.strike_price
# Use strike price to group option contracts and generate Greeks indicators
indicators_by_strike = {int(strike): get_indicators(group) for strike, group in groupby(sorted(contract_list, key=keyfunc), keyfunc)}
# Organize data in a dataframe
df = pd.DataFrame(indicators_by_strike.values(), index=indicators_by_strike.keys())</pre>
        <pre class="csharp">// Get all strike prices
var strikes = contractList.Select(x =&gt; x.ID.StrikePrice).Distinct().OrderBy(x =&gt; x);
// A dictionary to hold greeks data
var greeks = new Dictionary&lt;decimal, (decimal IVCall, decimal IVPut,
    decimal DeltaCall, decimal DeltaPut,
    decimal GammaCall, decimal GammaPut,
    decimal VegaCall, decimal VegaPut,
    decimal ThetaCall, decimal ThetaPut,
    decimal RhoCall, decimal RhoPut)&gt;();

// Iterate each strike and obtain all the greek and IV indicator values
foreach (var strike in strikes)
{
    // Get call and put contract of the same strike
    var filtered = contractList.Where(x =&gt; x.ID.StrikePrice == strike).ToList();
    var call = filtered.SingleOrDefault(x =&gt; x.ID.OptionRight == OptionRight.Call);
    var put = filtered.SingleOrDefault(x =&gt; x.ID.OptionRight == OptionRight.Put);
    // If either call or put absent, ignore
    if (call == null || put == null) continue;

    // Generate the IV and Greeks data
    greeks[strike] = GetIndicators(call, put);
}</pre>
    </div>

    <p>(Optional) We can also plot the Implied Volatility smile across different strike prices:</p>
    <div class="section-example-container">
        <pre class="python">df[['iv_call', 'iv_put']].plot(kind='line', title=f"IV by Strike", ylabel=field, xlabel="Strike", figsize=(8, 6))</pre>
        <pre class="csharp">// Plot IV by strikes for both call and put
var ivCall = Chart2D.Chart.Line&lt;decimal, decimal, string&gt;(
    greeks.Select(kvp =&gt; kvp.Key),
    greeks.Select(kvp =&gt; kvp.Value.IVCall)
);
var ivPut = Chart2D.Chart.Line&lt;decimal, decimal, string&gt;(
    greeks.Select(kvp =&gt; kvp.Key),
    greeks.Select(kvp =&gt; kvp.Value.IVPut)
);

// Combine 2 line charts in the same plot
var chartList = new List&lt;GenericChart.GenericChart&gt;();
chartList.Add(ivCall);
chartList.Add(ivPut);
var combinedChart = Plotly.NET.Chart.Combine(chartList);

// Set the title, x-axis and y-axis labels
LinearAxis xAxis = new LinearAxis();
xAxis.SetValue("title", "Strike");
LinearAxis yAxis = new LinearAxis();
yAxis.SetValue("title", "IV");
Title title = Title.init($"Implied Volatility by Strikes");

// Set up layout
Layout layout = new Layout();
layout.SetValue("xaxis", xAxis);
layout.SetValue("yaxis", yAxis);
layout.SetValue("title", title);
combinedChart.WithLayout(layout);

// Display the plot
HTML(GenericChart.toChartHTML(combinedChart))</pre>
    </div>

    <img class="python docs-image" src="https://cdn.quantconnect.com/i/tu/iv-smile-research-py.png" alt="Implied Volatilities by Strikes">
    <img class="csharp docs-image" src="https://cdn.quantconnect.com/i/tu/iv-smile-research-cs.png" alt="Implied Volatilities by Strikes">
</ol>
<p>For a full example, see the following project:</p>
<div class="python">
    <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
        <div class="qc-embed-dummy" style="padding-top: 56.25%;"></div>
        <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
            <iframe class="qc-embed-backtest" height="100%" width="100%" style="border: 1px solid #ccc; padding: 0; margin: 0;" src="https://www.quantconnect.com/terminal/processCache?request=embedded_backtest_d12f9d51be0efd2275bfbc69e010af29.html"></iframe>
        </div>
    </div>
</div>

<div class="csharp">
    <div class="qc-embed-frame" style="display: inline-block; position: relative; width: 100%; min-height: 100px; min-width: 300px;">
        <div class="qc-embed-dummy" style="padding-top: 56.25%;"></div>
        <div class="qc-embed-element" style="position: absolute; top: 0; bottom: 0; left: 0; right: 0;">
            <iframe class="qc-embed-backtest" height="100%" width="100%" style="border: 1px solid #ccc; padding: 0; margin: 0;" src="https://www.quantconnect.com/terminal/processCache?request=embedded_backtest_64ebd1394df3ba74e0c202a587b7349d.html"></iframe>
        </div>
    </div>
</div>
